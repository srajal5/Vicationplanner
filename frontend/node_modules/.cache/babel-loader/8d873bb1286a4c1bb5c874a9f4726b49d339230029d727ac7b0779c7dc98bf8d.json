{"ast":null,"code":"import { DEV_OR_STAGING_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from \"./constants-ByUssRbE.mjs\";\nimport { isomorphicAtob } from \"./isomorphicAtob-DybBXGFR.mjs\";\nimport { isomorphicBtoa } from \"./isomorphicBtoa-Dr7WubZv.mjs\";\n\n//#region src/keys.ts\n/** Prefix used for production publishable keys */\nconst PUBLISHABLE_KEY_LIVE_PREFIX = \"pk_live_\";\n/** Prefix used for development publishable keys */\nconst PUBLISHABLE_KEY_TEST_PREFIX = \"pk_test_\";\n/**\n* Regular expression that matches development frontend API keys.\n* Matches patterns like: foo-bar-13.clerk.accounts.dev.\n*/\nconst PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\n/**\n* Converts a frontend API URL into a base64-encoded publishable key.\n*\n* @param frontendApi - The frontend API URL (e.g., 'clerk.example.com').\n* @returns A base64-encoded publishable key with appropriate prefix (pk_live_ or pk_test_).\n*/\nfunction buildPublishableKey(frontendApi) {\n  const isDevKey = PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) || frontendApi.startsWith(\"clerk.\") && LEGACY_DEV_INSTANCE_SUFFIXES.some(s => frontendApi.endsWith(s));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${isomorphicBtoa(`${frontendApi}$`)}`;\n}\n/**\n* Validates that a decoded publishable key has the correct format.\n* The decoded value should be a frontend API followed by exactly one '$' at the end.\n*\n* @param decoded - The decoded publishable key string to validate.\n* @returns `true` if the decoded key has valid format, `false` otherwise.\n*/\nfunction isValidDecodedPublishableKey(decoded) {\n  if (!decoded.endsWith(\"$\")) return false;\n  const withoutTrailing = decoded.slice(0, -1);\n  if (withoutTrailing.includes(\"$\")) return false;\n  return withoutTrailing.includes(\".\");\n}\n/**\n* Parses and validates a publishable key, extracting the frontend API and instance type.\n*\n* @param key - The publishable key to parse.\n* @param options - Configuration options for parsing.\n* @param options.fatal\n* @param options.domain\n* @param options.proxyUrl\n* @param options.isSatellite\n* @returns Parsed publishable key object with instanceType and frontendApi, or null if invalid.\n*\n* @throws {Error} When options.fatal is true and key is missing or invalid.\n*/\nfunction parsePublishableKey(key, options = {}) {\n  key = key || \"\";\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal && !key) throw new Error(\"Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys\");\n    if (options.fatal && !isPublishableKey(key)) throw new Error(\"Publishable key not valid.\");\n    return null;\n  }\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? \"production\" : \"development\";\n  let decodedFrontendApi;\n  try {\n    decodedFrontendApi = isomorphicAtob(key.split(\"_\")[2]);\n  } catch {\n    if (options.fatal) throw new Error(\"Publishable key not valid: Failed to decode key.\");\n    return null;\n  }\n  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {\n    if (options.fatal) throw new Error(\"Publishable key not valid: Decoded key has invalid format.\");\n    return null;\n  }\n  let frontendApi = decodedFrontendApi.slice(0, -1);\n  if (options.proxyUrl) frontendApi = options.proxyUrl;else if (instanceType !== \"development\" && options.domain && options.isSatellite) frontendApi = `clerk.${options.domain}`;\n  return {\n    instanceType,\n    frontendApi\n  };\n}\n/**\n* Checks if the provided key is a valid publishable key.\n*\n* @param key - The key to be checked. Defaults to an empty string if not provided.\n* @returns `true` if 'key' is a valid publishable key, `false` otherwise.\n*/\nfunction isPublishableKey(key = \"\") {\n  try {\n    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n    if (!hasValidPrefix) return false;\n    const parts = key.split(\"_\");\n    if (parts.length !== 3) return false;\n    const encodedPart = parts[2];\n    if (!encodedPart) return false;\n    const decoded = isomorphicAtob(encodedPart);\n    return isValidDecodedPublishableKey(decoded);\n  } catch {\n    return false;\n  }\n}\n/**\n* Creates a memoized cache for checking if URLs are development or staging environments.\n* Uses a Map to cache results for better performance on repeated checks.\n*\n* @returns An object with an isDevOrStagingUrl method that checks if a URL is dev/staging.\n*/\nfunction createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = new Map();\n  return {\n    isDevOrStagingUrl: url => {\n      if (!url) return false;\n      const hostname = typeof url === \"string\" ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === void 0) {\n        res = DEV_OR_STAGING_SUFFIXES.some(s => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    }\n  };\n}\n/**\n* Checks if a publishable key is for a development environment.\n* Supports both legacy format (test_) and new format (pk_test_).\n*\n* @param apiKey - The API key to check.\n* @returns `true` if the key is for development, `false` otherwise.\n*/\nfunction isDevelopmentFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"pk_test_\");\n}\n/**\n* Checks if a publishable key is for a production environment.\n* Supports both legacy format (live_) and new format (pk_live_).\n*\n* @param apiKey - The API key to check.\n* @returns `true` if the key is for production, `false` otherwise.\n*/\nfunction isProductionFromPublishableKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"pk_live_\");\n}\n/**\n* Checks if a secret key is for a development environment.\n* Supports both legacy format (test_) and new format (sk_test_).\n*\n* @param apiKey - The secret key to check.\n* @returns `true` if the key is for development, `false` otherwise.\n*/\nfunction isDevelopmentFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"test_\") || apiKey.startsWith(\"sk_test_\");\n}\n/**\n* Checks if a secret key is for a production environment.\n* Supports both legacy format (live_) and new format (sk_live_).\n*\n* @param apiKey - The secret key to check.\n* @returns `true` if the key is for production, `false` otherwise.\n*/\nfunction isProductionFromSecretKey(apiKey) {\n  return apiKey.startsWith(\"live_\") || apiKey.startsWith(\"sk_live_\");\n}\n/**\n* Generates a unique cookie suffix based on the publishable key using SHA-1 hashing.\n* The suffix is base64-encoded and URL-safe (+ and / characters are replaced).\n*\n* @param publishableKey - The publishable key to generate suffix from.\n* @param subtle - The SubtleCrypto interface to use for hashing (defaults to globalThis.crypto.subtle).\n* @returns A promise that resolves to an 8-character URL-safe base64 string.\n*/\nasync function getCookieSuffix(publishableKey, subtle = globalThis.crypto.subtle) {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest(\"sha-1\", data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  return isomorphicBtoa(stringDigest).replace(/\\+/gi, \"-\").replace(/\\//gi, \"_\").substring(0, 8);\n}\n/**\n* Creates a suffixed cookie name by appending the cookie suffix to the base name.\n* Used to create unique cookie names based on the publishable key.\n*\n* @param cookieName - The base cookie name.\n* @param cookieSuffix - The suffix to append (typically generated by getCookieSuffix).\n* @returns The suffixed cookie name in format: `${cookieName}_${cookieSuffix}`.\n*/\nconst getSuffixedCookieName = (cookieName, cookieSuffix) => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n\n//#endregion\nexport { buildPublishableKey, createDevOrStagingUrlCache, getCookieSuffix, getSuffixedCookieName, isDevelopmentFromPublishableKey, isDevelopmentFromSecretKey, isProductionFromPublishableKey, isProductionFromSecretKey, isPublishableKey, parsePublishableKey };","map":{"version":3,"names":["PUBLISHABLE_KEY_LIVE_PREFIX","PUBLISHABLE_KEY_TEST_PREFIX","PUBLISHABLE_FRONTEND_API_DEV_REGEX","buildPublishableKey","frontendApi","isDevKey","test","startsWith","LEGACY_DEV_INSTANCE_SUFFIXES","some","s","endsWith","keyPrefix","isomorphicBtoa","isValidDecodedPublishableKey","decoded","withoutTrailing","slice","includes","parsePublishableKey","key","options","isPublishableKey","fatal","Error","instanceType","decodedFrontendApi","isomorphicAtob","split","proxyUrl","domain","isSatellite","hasValidPrefix","parts","length","encodedPart","createDevOrStagingUrlCache","devOrStagingUrlCache","Map","isDevOrStagingUrl","url","hostname","res","get","DEV_OR_STAGING_SUFFIXES","set","isDevelopmentFromPublishableKey","apiKey","isProductionFromPublishableKey","isDevelopmentFromSecretKey","isProductionFromSecretKey","getCookieSuffix","publishableKey","subtle","globalThis","crypto","data","TextEncoder","encode","digest","stringDigest","String","fromCharCode","Uint8Array","replace","substring","getSuffixedCookieName","cookieName","cookieSuffix"],"sources":["C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\keys.ts"],"sourcesContent":["import { DEV_OR_STAGING_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from './constants';\nimport { isomorphicAtob } from './isomorphicAtob';\nimport { isomorphicBtoa } from './isomorphicBtoa';\nimport type { PublishableKey } from './types';\n\n/**\n * Configuration options for parsing publishable keys.\n */\ntype ParsePublishableKeyOptions = {\n  /** Whether to throw an error if parsing fails */\n  fatal?: boolean;\n  /** Custom domain to use for satellite instances */\n  domain?: string;\n  /** Proxy URL to use instead of the decoded frontend API */\n  proxyUrl?: string;\n  /** Whether this is a satellite instance */\n  isSatellite?: boolean;\n};\n\n/** Prefix used for production publishable keys */\nconst PUBLISHABLE_KEY_LIVE_PREFIX = 'pk_live_';\n\n/** Prefix used for development publishable keys */\nconst PUBLISHABLE_KEY_TEST_PREFIX = 'pk_test_';\n\n/**\n * Regular expression that matches development frontend API keys.\n * Matches patterns like: foo-bar-13.clerk.accounts.dev.\n */\nconst PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\n\n/**\n * Converts a frontend API URL into a base64-encoded publishable key.\n *\n * @param frontendApi - The frontend API URL (e.g., 'clerk.example.com').\n * @returns A base64-encoded publishable key with appropriate prefix (pk_live_ or pk_test_).\n */\nexport function buildPublishableKey(frontendApi: string): string {\n  const isDevKey =\n    PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) ||\n    (frontendApi.startsWith('clerk.') && LEGACY_DEV_INSTANCE_SUFFIXES.some(s => frontendApi.endsWith(s)));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${isomorphicBtoa(`${frontendApi}$`)}`;\n}\n\n/**\n * Validates that a decoded publishable key has the correct format.\n * The decoded value should be a frontend API followed by exactly one '$' at the end.\n *\n * @param decoded - The decoded publishable key string to validate.\n * @returns `true` if the decoded key has valid format, `false` otherwise.\n */\nfunction isValidDecodedPublishableKey(decoded: string): boolean {\n  if (!decoded.endsWith('$')) {\n    return false;\n  }\n\n  const withoutTrailing = decoded.slice(0, -1);\n  if (withoutTrailing.includes('$')) {\n    return false;\n  }\n\n  return withoutTrailing.includes('.');\n}\n\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: ParsePublishableKeyOptions & { fatal: true },\n): PublishableKey;\nexport function parsePublishableKey(\n  key: string | undefined,\n  options?: ParsePublishableKeyOptions,\n): PublishableKey | null;\n/**\n * Parses and validates a publishable key, extracting the frontend API and instance type.\n *\n * @param key - The publishable key to parse.\n * @param options - Configuration options for parsing.\n * @param options.fatal\n * @param options.domain\n * @param options.proxyUrl\n * @param options.isSatellite\n * @returns Parsed publishable key object with instanceType and frontendApi, or null if invalid.\n *\n * @throws {Error} When options.fatal is true and key is missing or invalid.\n */\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: { fatal?: boolean; domain?: string; proxyUrl?: string; isSatellite?: boolean } = {},\n): PublishableKey | null {\n  key = key || '';\n\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal && !key) {\n      throw new Error(\n        'Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys',\n      );\n    }\n    if (options.fatal && !isPublishableKey(key)) {\n      throw new Error('Publishable key not valid.');\n    }\n    return null;\n  }\n\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? 'production' : 'development';\n\n  let decodedFrontendApi: string;\n  try {\n    decodedFrontendApi = isomorphicAtob(key.split('_')[2]);\n  } catch {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Failed to decode key.');\n    }\n    return null;\n  }\n\n  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Decoded key has invalid format.');\n    }\n    return null;\n  }\n\n  let frontendApi = decodedFrontendApi.slice(0, -1);\n\n  if (options.proxyUrl) {\n    frontendApi = options.proxyUrl;\n  } else if (instanceType !== 'development' && options.domain && options.isSatellite) {\n    frontendApi = `clerk.${options.domain}`;\n  }\n\n  return {\n    instanceType,\n    frontendApi,\n  };\n}\n\n/**\n * Checks if the provided key is a valid publishable key.\n *\n * @param key - The key to be checked. Defaults to an empty string if not provided.\n * @returns `true` if 'key' is a valid publishable key, `false` otherwise.\n */\nexport function isPublishableKey(key: string = '') {\n  try {\n    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n\n    if (!hasValidPrefix) {\n      return false;\n    }\n\n    const parts = key.split('_');\n    if (parts.length !== 3) {\n      return false;\n    }\n\n    const encodedPart = parts[2];\n    if (!encodedPart) {\n      return false;\n    }\n\n    const decoded = isomorphicAtob(encodedPart);\n    return isValidDecodedPublishableKey(decoded);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Creates a memoized cache for checking if URLs are development or staging environments.\n * Uses a Map to cache results for better performance on repeated checks.\n *\n * @returns An object with an isDevOrStagingUrl method that checks if a URL is dev/staging.\n */\nexport function createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = new Map<string, boolean>();\n\n  return {\n    /**\n     * Checks if a URL is a development or staging environment.\n     *\n     * @param url - The URL to check (string or URL object).\n     * @returns `true` if the URL is a development or staging environment, `false` otherwise.\n     */\n    isDevOrStagingUrl: (url: string | URL): boolean => {\n      if (!url) {\n        return false;\n      }\n\n      const hostname = typeof url === 'string' ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === undefined) {\n        res = DEV_OR_STAGING_SUFFIXES.some(s => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    },\n  };\n}\n\n/**\n * Checks if a publishable key is for a development environment.\n * Supports both legacy format (test_) and new format (pk_test_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('pk_test_');\n}\n\n/**\n * Checks if a publishable key is for a production environment.\n * Supports both legacy format (live_) and new format (pk_live_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('pk_live_');\n}\n\n/**\n * Checks if a secret key is for a development environment.\n * Supports both legacy format (test_) and new format (sk_test_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('sk_test_');\n}\n\n/**\n * Checks if a secret key is for a production environment.\n * Supports both legacy format (live_) and new format (sk_live_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('sk_live_');\n}\n\n/**\n * Generates a unique cookie suffix based on the publishable key using SHA-1 hashing.\n * The suffix is base64-encoded and URL-safe (+ and / characters are replaced).\n *\n * @param publishableKey - The publishable key to generate suffix from.\n * @param subtle - The SubtleCrypto interface to use for hashing (defaults to globalThis.crypto.subtle).\n * @returns A promise that resolves to an 8-character URL-safe base64 string.\n */\nexport async function getCookieSuffix(\n  publishableKey: string,\n  subtle: SubtleCrypto = globalThis.crypto.subtle,\n): Promise<string> {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest('sha-1', data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  // Base 64 Encoding with URL and Filename Safe Alphabet: https://datatracker.ietf.org/doc/html/rfc4648#section-5\n  return isomorphicBtoa(stringDigest).replace(/\\+/gi, '-').replace(/\\//gi, '_').substring(0, 8);\n}\n\n/**\n * Creates a suffixed cookie name by appending the cookie suffix to the base name.\n * Used to create unique cookie names based on the publishable key.\n *\n * @param cookieName - The base cookie name.\n * @param cookieSuffix - The suffix to append (typically generated by getCookieSuffix).\n * @returns The suffixed cookie name in format: `${cookieName}_${cookieSuffix}`.\n */\nexport const getSuffixedCookieName = (cookieName: string, cookieSuffix: string): string => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}