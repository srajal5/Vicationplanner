{"ast":null,"code":"//#region src/eventBus.ts\n/**\n* @internal\n*/\nconst _on = (eventToHandlersMap, latestPayloadMap, event, handler, opts) => {\n  const {\n    notify\n  } = opts || {};\n  let handlers = eventToHandlersMap.get(event);\n  if (!handlers) {\n    handlers = [];\n    eventToHandlersMap.set(event, handlers);\n  }\n  handlers.push(handler);\n  if (notify && latestPayloadMap.has(event)) handler(latestPayloadMap.get(event));\n};\n/**\n* @internal\n*/\nconst _dispatch = (eventToHandlersMap, event, payload) => (eventToHandlersMap.get(event) || []).map(h => h(payload));\n/**\n* @internal\n*/\nconst _off = (eventToHandlersMap, event, handler) => {\n  const handlers = eventToHandlersMap.get(event);\n  if (handlers) if (handler) handlers.splice(handlers.indexOf(handler) >>> 0, 1);else eventToHandlersMap.set(event, []);\n};\n/**\n* A ES6/2015 compatible 300 byte event bus\n*\n* Creates a strongly-typed event bus that enables publish/subscribe communication between components.\n*\n* @template Events - A record type that maps event names to their payload types\n* @returns An EventBus instance with the following methods:\n* - `on`: Subscribe to an event\n* - `onPreDispatch`: Subscribe to an event, triggered before regular subscribers\n* - `emit`: Publish an event with payload\n* - `off`: Unsubscribe from an event\n* - `offPreDispatch`: Unsubscribe from a pre-dispatch event\n*\n* @example\n* // Define event types\n* const eventBus = createEventBus<{\n*   'user-login': { userId: string; timestamp: number };\n*   'data-updated': { records: any[] };\n*   'error': Error;\n* }>();\n*\n* // Subscribe to events\n* eventBus.on('user-login', ({ userId, timestamp }) => {\n*   console.log(`User ${userId} logged in at ${timestamp}`);\n* });\n*\n* // Subscribe with immediate notification if event was already dispatched\n* eventBus.on('user-login', (payload) => {\n*   // This will be called immediately if 'user-login' was previously dispatched\n* }, { notify: true });\n*\n* // Publish an event\n* eventBus.emit('user-login', { userId: 'abc123', timestamp: Date.now() });\n*\n* // Unsubscribe from event\n* const handler = (payload) => console.log(payload);\n* eventBus.on('error', handler);\n* // Later...\n* eventBus.off('error', handler);\n*\n* // Unsubscribe all handlers for an event\n* eventBus.off('data-updated');\n*/\nconst createEventBus = () => {\n  const eventToHandlersMap = new Map();\n  const latestPayloadMap = new Map();\n  const eventToPredispatchHandlersMap = new Map();\n  const emit = (event, payload) => {\n    latestPayloadMap.set(event, payload);\n    _dispatch(eventToPredispatchHandlersMap, event, payload);\n    _dispatch(eventToHandlersMap, event, payload);\n  };\n  return {\n    on: function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return _on(eventToHandlersMap, latestPayloadMap, ...args);\n    },\n    prioritizedOn: function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return _on(eventToPredispatchHandlersMap, latestPayloadMap, ...args);\n    },\n    emit,\n    off: function () {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      return _off(eventToHandlersMap, ...args);\n    },\n    prioritizedOff: function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      return _off(eventToPredispatchHandlersMap, ...args);\n    },\n    internal: {\n      retrieveListeners: event => eventToHandlersMap.get(event) || []\n    }\n  };\n};\n\n//#endregion\nexport { createEventBus };","map":{"version":3,"names":["_on","_on: InternalOn","eventToHandlersMap","latestPayloadMap","event","handler","opts","notify","handlers","get","set","push","has","_dispatch","_dispatch: InternalDispatch","payload","map","h","_off","_off: InternalOff","splice","indexOf","createEventBus","Map","eventToPredispatchHandlersMap","emit","emit: EventBus<Events>['emit']","on","_len","arguments","length","args","Array","_key","prioritizedOn","_len2","_key2","off","_len3","_key3","prioritizedOff","_len4","_key4","internal","retrieveListeners"],"sources":["C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\eventBus.ts"],"sourcesContent":["/**\n * Type definition for event handler functions\n */\ntype EventHandler<Events extends Record<string, unknown>, Key extends keyof Events> = (payload: Events[Key]) => void;\n\n/**\n * @interface\n * Strongly-typed event bus interface that enables type-safe publish/subscribe patterns\n */\ntype EventBus<Events extends Record<string, unknown>> = {\n  /**\n   * Subscribe to an event\n   *\n   * @param event - The event name to subscribe to\n   * @param handler - The callback function to execute when the event is dispatched\n   * @param opts - Optional configuration\n   * @param opts.notify - If true and the event was previously dispatched, handler will be called immediately with the latest payload\n   * @returns void\n   */\n  on: <Event extends keyof Events>(\n    event: Event,\n    handler: EventHandler<Events, Event>,\n    opts?: { notify?: boolean },\n  ) => void;\n\n  /**\n   * Subscribe to an event with pre-dispatch priority\n   * Pre-dispatch handlers are called before regular event handlers when an event is dispatched\n   *\n   * @param event - The event name to subscribe to\n   * @param handler - The callback function to execute when the event is dispatched\n   * @returns void\n   */\n  prioritizedOn: <Event extends keyof Events>(event: Event, handler: EventHandler<Events, Event>) => void;\n\n  /**\n   * Publish an event with a payload\n   * Triggers all registered handlers for the event\n   *\n   * @param event - The event name to publish\n   * @param payload - The data to pass to event handlers\n   * @returns void\n   */\n  emit: <Event extends keyof Events>(event: Event, payload: Events[Event]) => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param event - The event name to unsubscribe from\n   * @param handler - Optional specific handler to remove. If omitted, all handlers for the event are removed\n   * @returns void\n   */\n  off: <Event extends keyof Events>(event: Event, handler?: EventHandler<Events, Event>) => void;\n\n  /**\n   * Unsubscribe from a pre-dispatch event\n   *\n   * @param event - The event name to unsubscribe from\n   * @param handler - Optional specific handler to remove. If omitted, all pre-dispatch handlers for the event are removed\n   * @returns void\n   */\n  prioritizedOff: <Event extends keyof Events>(event: Event, handler?: EventHandler<Events, Event>) => void;\n\n  /**\n   * Internal utilities for the event bus\n   */\n  internal: {\n    /**\n     * Retrieve all listeners for a specific event\n     *\n     * @param event - The event name to get listeners for\n     * @returns Array of handler functions\n     */\n    retrieveListeners: <Event extends keyof Events>(event: Event) => Array<(...args: any[]) => void>;\n  };\n};\n\n/**\n * @internal\n */\ntype InternalOn = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  latestPayloadMap: Map<keyof Events, any>,\n  event: Event,\n  handler: EventHandler<Events, Event>,\n  opts?: { notify?: boolean },\n) => void;\n\n/**\n * @internal\n */\ntype InternalOff = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  event: Event,\n  handler?: EventHandler<Events, Event>,\n) => void;\n\n/**\n * @internal\n */\ntype InternalDispatch = <Events extends Record<string, unknown>, Event extends keyof Events>(\n  eventToHandlersMap: Map<keyof Events, Array<(...args: any[]) => void>>,\n  event: Event,\n  payload: Events[Event],\n) => void;\n\n/**\n * @internal\n */\nconst _on: InternalOn = (eventToHandlersMap, latestPayloadMap, event, handler, opts) => {\n  const { notify } = opts || {};\n  let handlers = eventToHandlersMap.get(event);\n\n  if (!handlers) {\n    handlers = [];\n    eventToHandlersMap.set(event, handlers);\n  }\n\n  handlers.push(handler);\n\n  if (notify && latestPayloadMap.has(event)) {\n    handler(latestPayloadMap.get(event));\n  }\n};\n\n/**\n * @internal\n */\nconst _dispatch: InternalDispatch = (eventToHandlersMap, event, payload) =>\n  (eventToHandlersMap.get(event) || []).map(h => h(payload));\n\n/**\n * @internal\n */\nconst _off: InternalOff = (eventToHandlersMap, event, handler) => {\n  const handlers = eventToHandlersMap.get(event);\n  if (handlers) {\n    if (handler) {\n      handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n    } else {\n      eventToHandlersMap.set(event, []);\n    }\n  }\n};\n\n/**\n * A ES6/2015 compatible 300 byte event bus\n *\n * Creates a strongly-typed event bus that enables publish/subscribe communication between components.\n *\n * @template Events - A record type that maps event names to their payload types\n * @returns An EventBus instance with the following methods:\n * - `on`: Subscribe to an event\n * - `onPreDispatch`: Subscribe to an event, triggered before regular subscribers\n * - `emit`: Publish an event with payload\n * - `off`: Unsubscribe from an event\n * - `offPreDispatch`: Unsubscribe from a pre-dispatch event\n *\n * @example\n * // Define event types\n * const eventBus = createEventBus<{\n *   'user-login': { userId: string; timestamp: number };\n *   'data-updated': { records: any[] };\n *   'error': Error;\n * }>();\n *\n * // Subscribe to events\n * eventBus.on('user-login', ({ userId, timestamp }) => {\n *   console.log(`User ${userId} logged in at ${timestamp}`);\n * });\n *\n * // Subscribe with immediate notification if event was already dispatched\n * eventBus.on('user-login', (payload) => {\n *   // This will be called immediately if 'user-login' was previously dispatched\n * }, { notify: true });\n *\n * // Publish an event\n * eventBus.emit('user-login', { userId: 'abc123', timestamp: Date.now() });\n *\n * // Unsubscribe from event\n * const handler = (payload) => console.log(payload);\n * eventBus.on('error', handler);\n * // Later...\n * eventBus.off('error', handler);\n *\n * // Unsubscribe all handlers for an event\n * eventBus.off('data-updated');\n */\nexport const createEventBus = <Events extends Record<string, unknown>>(): EventBus<Events> => {\n  const eventToHandlersMap = new Map<keyof Events, Array<(...args: any[]) => void>>();\n  const latestPayloadMap = new Map<keyof Events, any>();\n  const eventToPredispatchHandlersMap = new Map<keyof Events, Array<(...args: any[]) => void>>();\n\n  const emit: EventBus<Events>['emit'] = (event, payload) => {\n    latestPayloadMap.set(event, payload);\n    _dispatch(eventToPredispatchHandlersMap, event, payload);\n    _dispatch(eventToHandlersMap, event, payload);\n  };\n\n  return {\n    // Subscribe to an event\n    on: (...args) => _on(eventToHandlersMap, latestPayloadMap, ...args),\n    // Subscribe to an event with priority\n    // Registered handlers with `prioritizedOn` will be called before handlers registered with `on`\n    prioritizedOn: (...args) => _on(eventToPredispatchHandlersMap, latestPayloadMap, ...args),\n    // Dispatch an event\n    emit,\n    // Unsubscribe from an event\n    off: (...args) => _off(eventToHandlersMap, ...args),\n    // Unsubscribe from an event with priority\n    // Unsubscribes handlers only registered with `prioritizedOn`\n    prioritizedOff: (...args) => _off(eventToPredispatchHandlersMap, ...args),\n\n    // Internal utilities\n    internal: {\n      retrieveListeners: event => eventToHandlersMap.get(event) || [],\n    },\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}