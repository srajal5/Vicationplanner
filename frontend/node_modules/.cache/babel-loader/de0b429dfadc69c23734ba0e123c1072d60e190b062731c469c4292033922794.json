{"ast":null,"code":"//#region src/authorization.ts\nconst TYPES_TO_OBJECTS = {\n  strict_mfa: {\n    afterMinutes: 10,\n    level: \"multi_factor\"\n  },\n  strict: {\n    afterMinutes: 10,\n    level: \"second_factor\"\n  },\n  moderate: {\n    afterMinutes: 60,\n    level: \"second_factor\"\n  },\n  lax: {\n    afterMinutes: 1440,\n    level: \"second_factor\"\n  }\n};\nconst ALLOWED_LEVELS = new Set([\"first_factor\", \"second_factor\", \"multi_factor\"]);\nconst ALLOWED_TYPES = new Set([\"strict_mfa\", \"strict\", \"moderate\", \"lax\"]);\nconst isValidMaxAge = maxAge => typeof maxAge === \"number\" && maxAge > 0;\nconst isValidLevel = level => ALLOWED_LEVELS.has(level);\nconst isValidVerificationType = type => ALLOWED_TYPES.has(type);\nconst prefixWithOrg = value => value.replace(/^(org:)*/, \"org:\");\n/**\n* Checks if a user has the required organization-level authorization.\n* Verifies if the user has the specified role or permission within their organization.\n* @returns null, if unable to determine due to missing data or unspecified role/permission.\n*/\nconst checkOrgAuthorization = (params, options) => {\n  const {\n    orgId,\n    orgRole,\n    orgPermissions\n  } = options;\n  if (!params.role && !params.permission) return null;\n  if (!orgId || !orgRole || !orgPermissions) return null;\n  if (params.permission) return orgPermissions.includes(prefixWithOrg(params.permission));\n  if (params.role) return prefixWithOrg(orgRole) === prefixWithOrg(params.role);\n  return null;\n};\nconst checkForFeatureOrPlan = (claim, featureOrPlan) => {\n  const {\n    org: orgFeatures,\n    user: userFeatures\n  } = splitByScope(claim);\n  const [scope, _id] = featureOrPlan.split(\":\");\n  const id = _id || scope;\n  if (scope === \"org\") return orgFeatures.includes(id);else if (scope === \"user\") return userFeatures.includes(id);else return [...orgFeatures, ...userFeatures].includes(id);\n};\nconst checkBillingAuthorization = (params, options) => {\n  const {\n    features,\n    plans\n  } = options;\n  if (params.feature && features) return checkForFeatureOrPlan(features, params.feature);\n  if (params.plan && plans) return checkForFeatureOrPlan(plans, params.plan);\n  return null;\n};\nconst splitByScope = fea => {\n  const features = fea ? fea.split(\",\").map(f => f.trim()) : [];\n  return {\n    org: features.filter(f => f.split(\":\")[0].includes(\"o\")).map(f => f.split(\":\")[1]),\n    user: features.filter(f => f.split(\":\")[0].includes(\"u\")).map(f => f.split(\":\")[1])\n  };\n};\nconst validateReverificationConfig = config => {\n  if (!config) return false;\n  const convertConfigToObject = config$1 => {\n    if (typeof config$1 === \"string\") return TYPES_TO_OBJECTS[config$1];\n    return config$1;\n  };\n  const isValidStringValue = typeof config === \"string\" && isValidVerificationType(config);\n  const isValidObjectValue = typeof config === \"object\" && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);\n  if (isValidStringValue || isValidObjectValue) return convertConfigToObject.bind(null, config);\n  return false;\n};\n/**\n* Evaluates if the user meets re-verification authentication requirements.\n* Compares the user's factor verification ages against the specified maxAge.\n* Handles different verification levels (first factor, second factor, multi-factor).\n* @returns null, if requirements or verification data are missing.\n*/\nconst checkReverificationAuthorization = (params, {\n  factorVerificationAge\n}) => {\n  if (!params.reverification || !factorVerificationAge) return null;\n  const isValidReverification = validateReverificationConfig(params.reverification);\n  if (!isValidReverification) return null;\n  const {\n    level,\n    afterMinutes\n  } = isValidReverification();\n  const [factor1Age, factor2Age] = factorVerificationAge;\n  const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;\n  const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;\n  switch (level) {\n    case \"first_factor\":\n      return isValidFactor1;\n    case \"second_factor\":\n      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;\n    case \"multi_factor\":\n      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;\n  }\n};\n/**\n* Creates a function for comprehensive user authorization checks.\n* Combines organization-level and reverification authentication checks.\n* The returned function authorizes if both checks pass, or if at least one passes\n* when the other is indeterminate. Fails if userId is missing.\n*/\nconst createCheckAuthorization = options => {\n  return params => {\n    if (!options.userId) return false;\n    const billingAuthorization = checkBillingAuthorization(params, options);\n    const orgAuthorization = checkOrgAuthorization(params, options);\n    const reverificationAuthorization = checkReverificationAuthorization(params, options);\n    if ([billingAuthorization || orgAuthorization, reverificationAuthorization].some(a => a === null)) return [billingAuthorization || orgAuthorization, reverificationAuthorization].some(a => a === true);\n    return [billingAuthorization || orgAuthorization, reverificationAuthorization].every(a => a === true);\n  };\n};\n/**\n* Shared utility function that centralizes auth state resolution logic,\n* preventing duplication across different packages.\n* @internal\n*/\nconst resolveAuthState = ({\n  authObject: {\n    sessionId,\n    sessionStatus,\n    userId,\n    actor,\n    orgId,\n    orgRole,\n    orgSlug,\n    signOut,\n    getToken,\n    has,\n    sessionClaims\n  },\n  options: {\n    treatPendingAsSignedOut = true\n  }\n}) => {\n  if (sessionId === void 0 && userId === void 0) return {\n    isLoaded: false,\n    isSignedIn: void 0,\n    sessionId,\n    sessionClaims: void 0,\n    userId,\n    actor: void 0,\n    orgId: void 0,\n    orgRole: void 0,\n    orgSlug: void 0,\n    has: void 0,\n    signOut,\n    getToken\n  };\n  if (sessionId === null && userId === null) return {\n    isLoaded: true,\n    isSignedIn: false,\n    sessionId,\n    userId,\n    sessionClaims: null,\n    actor: null,\n    orgId: null,\n    orgRole: null,\n    orgSlug: null,\n    has: () => false,\n    signOut,\n    getToken\n  };\n  if (treatPendingAsSignedOut && sessionStatus === \"pending\") return {\n    isLoaded: true,\n    isSignedIn: false,\n    sessionId: null,\n    userId: null,\n    sessionClaims: null,\n    actor: null,\n    orgId: null,\n    orgRole: null,\n    orgSlug: null,\n    has: () => false,\n    signOut,\n    getToken\n  };\n  if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) return {\n    isLoaded: true,\n    isSignedIn: true,\n    sessionId,\n    sessionClaims,\n    userId,\n    actor: actor || null,\n    orgId,\n    orgRole,\n    orgSlug: orgSlug || null,\n    has,\n    signOut,\n    getToken\n  };\n  if (!!sessionId && !!sessionClaims && !!userId && !orgId) return {\n    isLoaded: true,\n    isSignedIn: true,\n    sessionId,\n    sessionClaims,\n    userId,\n    actor: actor || null,\n    orgId: null,\n    orgRole: null,\n    orgSlug: null,\n    has,\n    signOut,\n    getToken\n  };\n};\n\n//#endregion\nexport { createCheckAuthorization, resolveAuthState, splitByScope, validateReverificationConfig };","map":{"version":3,"names":["TYPES_TO_OBJECTS","strict_mfa","afterMinutes","level","strict","moderate","lax","ALLOWED_LEVELS","Set","ALLOWED_TYPES","isValidMaxAge","maxAge","isValidLevel","has","isValidVerificationType","type","prefixWithOrg","value","replace","checkOrgAuthorization","checkOrgAuthorization: CheckOrgAuthorization","params","options","orgId","orgRole","orgPermissions","role","permission","includes","checkForFeatureOrPlan","claim","featureOrPlan","org","orgFeatures","user","userFeatures","splitByScope","scope","_id","split","id","checkBillingAuthorization","checkBillingAuthorization: CheckBillingAuthorization","features","plans","feature","plan","fea","map","f","trim","filter","validateReverificationConfig","config","convertConfigToObject","config$1","isValidStringValue","isValidObjectValue","bind","checkReverificationAuthorization","checkReverificationAuthorization: CheckReverificationAuthorization","factorVerificationAge","reverification","isValidReverification","factor1Age","factor2Age","isValidFactor1","isValidFactor2","createCheckAuthorization","userId","billingAuthorization","orgAuthorization","reverificationAuthorization","some","a","every","resolveAuthState","authObject","sessionId","sessionStatus","actor","orgSlug","signOut","getToken","sessionClaims","treatPendingAsSignedOut","isLoaded","isSignedIn"],"sources":["C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\authorization.ts"],"sourcesContent":["import type {\n  ActClaim,\n  CheckAuthorizationWithCustomPermissions,\n  GetToken,\n  JwtPayload,\n  OrganizationCustomPermissionKey,\n  OrganizationCustomRoleKey,\n  PendingSessionOptions,\n  ReverificationConfig,\n  SessionStatusClaim,\n  SessionVerificationLevel,\n  SessionVerificationTypes,\n  SignOut,\n  UseAuthReturn,\n} from './types';\n\ntype TypesToConfig = Record<SessionVerificationTypes, Exclude<ReverificationConfig, SessionVerificationTypes>>;\ntype AuthorizationOptions = {\n  userId: string | null | undefined;\n  orgId: string | null | undefined;\n  orgRole: string | null | undefined;\n  orgPermissions: string[] | null | undefined;\n  factorVerificationAge: [number, number] | null;\n  features: string | null | undefined;\n  plans: string | null | undefined;\n};\n\ntype CheckOrgAuthorization = (\n  params: { role?: OrganizationCustomRoleKey; permission?: OrganizationCustomPermissionKey },\n  options: Pick<AuthorizationOptions, 'orgId' | 'orgRole' | 'orgPermissions'>,\n) => boolean | null;\n\ntype CheckBillingAuthorization = (\n  params: { feature?: string; plan?: string },\n  options: Pick<AuthorizationOptions, 'plans' | 'features'>,\n) => boolean | null;\n\ntype CheckReverificationAuthorization = (\n  params: {\n    reverification?: ReverificationConfig;\n  },\n  { factorVerificationAge }: AuthorizationOptions,\n) => boolean | null;\n\nconst TYPES_TO_OBJECTS: TypesToConfig = {\n  strict_mfa: {\n    afterMinutes: 10,\n    level: 'multi_factor',\n  },\n  strict: {\n    afterMinutes: 10,\n    level: 'second_factor',\n  },\n  moderate: {\n    afterMinutes: 60,\n    level: 'second_factor',\n  },\n  lax: {\n    afterMinutes: 1_440,\n    level: 'second_factor',\n  },\n};\n\nconst ALLOWED_LEVELS = new Set<SessionVerificationLevel>(['first_factor', 'second_factor', 'multi_factor']);\n\nconst ALLOWED_TYPES = new Set<SessionVerificationTypes>(['strict_mfa', 'strict', 'moderate', 'lax']);\n\n// Helper functions\nconst isValidMaxAge = (maxAge: any) => typeof maxAge === 'number' && maxAge > 0;\nconst isValidLevel = (level: any) => ALLOWED_LEVELS.has(level);\nconst isValidVerificationType = (type: any) => ALLOWED_TYPES.has(type);\n\nconst prefixWithOrg = (value: string) => value.replace(/^(org:)*/, 'org:');\n\n/**\n * Checks if a user has the required organization-level authorization.\n * Verifies if the user has the specified role or permission within their organization.\n * @returns null, if unable to determine due to missing data or unspecified role/permission.\n */\nconst checkOrgAuthorization: CheckOrgAuthorization = (params, options) => {\n  const { orgId, orgRole, orgPermissions } = options;\n  if (!params.role && !params.permission) {\n    return null;\n  }\n\n  if (!orgId || !orgRole || !orgPermissions) {\n    return null;\n  }\n\n  if (params.permission) {\n    return orgPermissions.includes(prefixWithOrg(params.permission));\n  }\n\n  if (params.role) {\n    return prefixWithOrg(orgRole) === prefixWithOrg(params.role);\n  }\n  return null;\n};\n\nconst checkForFeatureOrPlan = (claim: string, featureOrPlan: string) => {\n  const { org: orgFeatures, user: userFeatures } = splitByScope(claim);\n  const [scope, _id] = featureOrPlan.split(':');\n  const id = _id || scope;\n\n  if (scope === 'org') {\n    return orgFeatures.includes(id);\n  } else if (scope === 'user') {\n    return userFeatures.includes(id);\n  } else {\n    // Since org scoped features will not exist if there is not an active org, merging is safe.\n    return [...orgFeatures, ...userFeatures].includes(id);\n  }\n};\n\nconst checkBillingAuthorization: CheckBillingAuthorization = (params, options) => {\n  const { features, plans } = options;\n\n  if (params.feature && features) {\n    return checkForFeatureOrPlan(features, params.feature);\n  }\n\n  if (params.plan && plans) {\n    return checkForFeatureOrPlan(plans, params.plan);\n  }\n  return null;\n};\n\nconst splitByScope = (fea: string | null | undefined) => {\n  const features = fea ? fea.split(',').map(f => f.trim()) : [];\n\n  // TODO: make this more efficient\n  return {\n    org: features.filter(f => f.split(':')[0].includes('o')).map(f => f.split(':')[1]),\n    user: features.filter(f => f.split(':')[0].includes('u')).map(f => f.split(':')[1]),\n  };\n};\n\nconst validateReverificationConfig = (config: ReverificationConfig | undefined | null) => {\n  if (!config) {\n    return false;\n  }\n\n  const convertConfigToObject = (config: ReverificationConfig) => {\n    if (typeof config === 'string') {\n      return TYPES_TO_OBJECTS[config];\n    }\n    return config;\n  };\n\n  const isValidStringValue = typeof config === 'string' && isValidVerificationType(config);\n  const isValidObjectValue =\n    typeof config === 'object' && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);\n\n  if (isValidStringValue || isValidObjectValue) {\n    return convertConfigToObject.bind(null, config);\n  }\n\n  return false;\n};\n\n/**\n * Evaluates if the user meets re-verification authentication requirements.\n * Compares the user's factor verification ages against the specified maxAge.\n * Handles different verification levels (first factor, second factor, multi-factor).\n * @returns null, if requirements or verification data are missing.\n */\nconst checkReverificationAuthorization: CheckReverificationAuthorization = (params, { factorVerificationAge }) => {\n  if (!params.reverification || !factorVerificationAge) {\n    return null;\n  }\n\n  const isValidReverification = validateReverificationConfig(params.reverification);\n  if (!isValidReverification) {\n    return null;\n  }\n\n  const { level, afterMinutes } = isValidReverification();\n  const [factor1Age, factor2Age] = factorVerificationAge;\n\n  // -1 indicates the factor group (1fa,2fa) is not enabled\n  // -1 for 1fa is not a valid scenario, but we need to make sure we handle it properly\n  const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;\n  const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;\n\n  switch (level) {\n    case 'first_factor':\n      return isValidFactor1;\n    case 'second_factor':\n      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;\n    case 'multi_factor':\n      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;\n  }\n};\n\n/**\n * Creates a function for comprehensive user authorization checks.\n * Combines organization-level and reverification authentication checks.\n * The returned function authorizes if both checks pass, or if at least one passes\n * when the other is indeterminate. Fails if userId is missing.\n */\nconst createCheckAuthorization = (options: AuthorizationOptions): CheckAuthorizationWithCustomPermissions => {\n  return (params): boolean => {\n    if (!options.userId) {\n      return false;\n    }\n\n    const billingAuthorization = checkBillingAuthorization(params, options);\n    const orgAuthorization = checkOrgAuthorization(params, options);\n    const reverificationAuthorization = checkReverificationAuthorization(params, options);\n\n    if ([billingAuthorization || orgAuthorization, reverificationAuthorization].some(a => a === null)) {\n      return [billingAuthorization || orgAuthorization, reverificationAuthorization].some(a => a === true);\n    }\n\n    return [billingAuthorization || orgAuthorization, reverificationAuthorization].every(a => a === true);\n  };\n};\n\ntype AuthStateOptions = {\n  authObject: {\n    userId?: string | null;\n    sessionId?: string | null;\n    sessionStatus?: SessionStatusClaim | null;\n    sessionClaims?: JwtPayload | null;\n    actor?: ActClaim | null;\n    orgId?: string | null;\n    orgRole?: OrganizationCustomRoleKey | null;\n    orgSlug?: string | null;\n    orgPermissions?: OrganizationCustomPermissionKey[] | null;\n    getToken: GetToken;\n    signOut: SignOut;\n    has: (params: Parameters<CheckAuthorizationWithCustomPermissions>[0]) => boolean;\n  };\n  options: PendingSessionOptions;\n};\n\n/**\n * Shared utility function that centralizes auth state resolution logic,\n * preventing duplication across different packages.\n * @internal\n */\nconst resolveAuthState = ({\n  authObject: {\n    sessionId,\n    sessionStatus,\n    userId,\n    actor,\n    orgId,\n    orgRole,\n    orgSlug,\n    signOut,\n    getToken,\n    has,\n    sessionClaims,\n  },\n  options: { treatPendingAsSignedOut = true },\n}: AuthStateOptions): UseAuthReturn | undefined => {\n  if (sessionId === undefined && userId === undefined) {\n    return {\n      isLoaded: false,\n      isSignedIn: undefined,\n      sessionId,\n      sessionClaims: undefined,\n      userId,\n      actor: undefined,\n      orgId: undefined,\n      orgRole: undefined,\n      orgSlug: undefined,\n      has: undefined,\n      signOut,\n      getToken,\n    } as const;\n  }\n\n  if (sessionId === null && userId === null) {\n    return {\n      isLoaded: true,\n      isSignedIn: false,\n      sessionId,\n      userId,\n      sessionClaims: null,\n      actor: null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has: () => false,\n      signOut,\n      getToken,\n    } as const;\n  }\n\n  if (treatPendingAsSignedOut && sessionStatus === 'pending') {\n    return {\n      isLoaded: true,\n      isSignedIn: false,\n      sessionId: null,\n      userId: null,\n      sessionClaims: null,\n      actor: null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has: () => false,\n      signOut,\n      getToken,\n    } as const;\n  }\n\n  if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      sessionClaims,\n      userId,\n      actor: actor || null,\n      orgId,\n      orgRole,\n      orgSlug: orgSlug || null,\n      has,\n      signOut,\n      getToken,\n    } as const;\n  }\n\n  if (!!sessionId && !!sessionClaims && !!userId && !orgId) {\n    return {\n      isLoaded: true,\n      isSignedIn: true,\n      sessionId,\n      sessionClaims,\n      userId,\n      actor: actor || null,\n      orgId: null,\n      orgRole: null,\n      orgSlug: null,\n      has,\n      signOut,\n      getToken,\n    } as const;\n  }\n};\n\nexport { createCheckAuthorization, resolveAuthState, splitByScope, validateReverificationConfig };\n"],"mappings":";AA4CA,MAAMA,gBAAA,GAAkC;EACtCC,UAAA,EAAY;IACVC,YAAA,EAAc;IACdC,KAAA,EAAO;EACR;EACDC,MAAA,EAAQ;IACNF,YAAA,EAAc;IACdC,KAAA,EAAO;EACR;EACDE,QAAA,EAAU;IACRH,YAAA,EAAc;IACdC,KAAA,EAAO;EACR;EACDG,GAAA,EAAK;IACHJ,YAAA,EAAc;IACdC,KAAA,EAAO;EACR;AACF;AAED,MAAMI,cAAA,GAAiB,IAAIC,GAAA,CAA8B,CAAC,gBAAgB,iBAAiB,eAAe;AAE1G,MAAMC,aAAA,GAAgB,IAAID,GAAA,CAA8B,CAAC,cAAc,UAAU,YAAY,MAAM;AAGnG,MAAME,aAAA,GAAiBC,MAAA,WAAuBA,MAAA,KAAW,YAAYA,MAAA,GAAS;AAC9E,MAAMC,YAAA,GAAgBT,KAAA,IAAeI,cAAA,CAAeM,GAAA,CAAIV,KAAA,CAAM;AAC9D,MAAMW,uBAAA,GAA2BC,IAAA,IAAcN,aAAA,CAAcI,GAAA,CAAIE,IAAA,CAAK;AAEtE,MAAMC,aAAA,GAAiBC,KAAA,IAAkBA,KAAA,CAAMC,OAAA,CAAQ,YAAY,OAAO;;;;;;AAO1E,MAAMC,qBAAA,GAA+CC,CAACC,MAAA,EAAQC,OAAA,KAAY;EACxE,MAAM;IAAEC,KAAA;IAAOC,OAAA;IAASC;EAAA,CAAgB,GAAGH,OAAA;EAC3C,KAAKD,MAAA,CAAOK,IAAA,KAASL,MAAA,CAAOM,UAAA,EAC1B,OAAO;EAGT,KAAKJ,KAAA,KAAUC,OAAA,KAAYC,cAAA,EACzB,OAAO;EAGT,IAAIJ,MAAA,CAAOM,UAAA,EACT,OAAOF,cAAA,CAAeG,QAAA,CAASZ,aAAA,CAAcK,MAAA,CAAOM,UAAA,CAAW,CAAC;EAGlE,IAAIN,MAAA,CAAOK,IAAA,EACT,OAAOV,aAAA,CAAcQ,OAAA,CAAQ,KAAKR,aAAA,CAAcK,MAAA,CAAOK,IAAA,CAAK;EAE9D,OAAO;AACR;AAED,MAAMG,qBAAA,GAAwBA,CAACC,KAAA,EAAeC,aAAA,KAA0B;EACtE,MAAM;IAAEC,GAAA,EAAKC,WAAA;IAAaC,IAAA,EAAMC;EAAA,CAAc,GAAGC,YAAA,CAAaN,KAAA,CAAM;EACpE,MAAM,CAACO,KAAA,EAAOC,GAAA,CAAI,GAAGP,aAAA,CAAcQ,KAAA,CAAM,IAAI;EAC7C,MAAMC,EAAA,GAAKF,GAAA,IAAOD,KAAA;EAElB,IAAIA,KAAA,KAAU,OACZ,OAAOJ,WAAA,CAAYL,QAAA,CAASY,EAAA,CAAG,M,IACtBH,KAAA,KAAU,QACnB,OAAOF,YAAA,CAAaP,QAAA,CAASY,EAAA,CAAG,MAGhC,OAAO,CAAC,GAAGP,WAAA,EAAa,GAAGE,YAAa,EAACP,QAAA,CAASY,EAAA,CAAG;AAExD;AAED,MAAMC,yBAAA,GAAuDC,CAACrB,MAAA,EAAQC,OAAA,KAAY;EAChF,MAAM;IAAEqB,QAAA;IAAUC;EAAA,CAAO,GAAGtB,OAAA;EAE5B,IAAID,MAAA,CAAOwB,OAAA,IAAWF,QAAA,EACpB,OAAOd,qBAAA,CAAsBc,QAAA,EAAUtB,MAAA,CAAOwB,OAAA,CAAQ;EAGxD,IAAIxB,MAAA,CAAOyB,IAAA,IAAQF,KAAA,EACjB,OAAOf,qBAAA,CAAsBe,KAAA,EAAOvB,MAAA,CAAOyB,IAAA,CAAK;EAElD,OAAO;AACR;AAED,MAAMV,YAAA,GAAgBW,GAAA,IAAmC;EACvD,MAAMJ,QAAA,GAAWI,GAAA,GAAMA,GAAA,CAAIR,KAAA,CAAM,IAAI,CAACS,GAAA,CAAIC,CAAA,IAAKA,CAAA,CAAEC,IAAA,EAAM,CAAC,GAAG,EAAE;EAG7D,OAAO;IACLlB,GAAA,EAAKW,QAAA,CAASQ,MAAA,CAAOF,CAAA,IAAKA,CAAA,CAAEV,KAAA,CAAM,IAAI,CAAC,GAAGX,QAAA,CAAS,IAAI,CAAC,CAACoB,GAAA,CAAIC,CAAA,IAAKA,CAAA,CAAEV,KAAA,CAAM,IAAI,CAAC,GAAG;IAClFL,IAAA,EAAMS,QAAA,CAASQ,MAAA,CAAOF,CAAA,IAAKA,CAAA,CAAEV,KAAA,CAAM,IAAI,CAAC,GAAGX,QAAA,CAAS,IAAI,CAAC,CAACoB,GAAA,CAAIC,CAAA,IAAKA,CAAA,CAAEV,KAAA,CAAM,IAAI,CAAC;EACjF;AACF;AAED,MAAMa,4BAAA,GAAgCC,MAAA,IAAoD;EACxF,KAAKA,MAAA,EACH,OAAO;EAGT,MAAMC,qBAAA,GAAyBC,QAAA,IAAiC;IAC9D,WAAWA,QAAA,KAAW,UACpB,OAAOvD,gBAAA,CAAiBuD,QAAA;IAE1B,OAAOA,QAAA;EACR;EAED,MAAMC,kBAAA,UAA4BH,MAAA,KAAW,YAAYvC,uBAAA,CAAwBuC,MAAA,CAAO;EACxF,MAAMI,kBAAA,UACGJ,MAAA,KAAW,YAAYzC,YAAA,CAAayC,MAAA,CAAOlD,KAAA,CAAM,IAAIO,aAAA,CAAc2C,MAAA,CAAOnD,YAAA,CAAa;EAEhG,IAAIsD,kBAAA,IAAsBC,kBAAA,EACxB,OAAOH,qBAAA,CAAsBI,IAAA,CAAK,MAAML,MAAA,CAAO;EAGjD,OAAO;AACR;;;;;;;AAQD,MAAMM,gCAAA,GAAqEC,CAACvC,MAAA,EAAQ;EAAEwC;AAAA,CAAuB,KAAK;EAChH,KAAKxC,MAAA,CAAOyC,cAAA,KAAmBD,qBAAA,EAC7B,OAAO;EAGT,MAAME,qBAAA,GAAwBX,4BAAA,CAA6B/B,MAAA,CAAOyC,cAAA,CAAe;EACjF,KAAKC,qBAAA,EACH,OAAO;EAGT,MAAM;IAAE5D,KAAA;IAAOD;EAAA,CAAc,GAAG6D,qBAAA,EAAuB;EACvD,MAAM,CAACC,UAAA,EAAYC,UAAA,CAAW,GAAGJ,qBAAA;EAIjC,MAAMK,cAAA,GAAiBF,UAAA,KAAe,KAAK9D,YAAA,GAAe8D,UAAA,GAAa;EACvE,MAAMG,cAAA,GAAiBF,UAAA,KAAe,KAAK/D,YAAA,GAAe+D,UAAA,GAAa;EAEvE,QAAQ9D,KAAA;IACN,KAAK;MACH,OAAO+D,cAAA;IACT,KAAK;MACH,OAAOD,UAAA,KAAe,KAAKE,cAAA,GAAiBD,cAAA;IAC9C,KAAK;MACH,OAAOD,UAAA,KAAe,KAAKC,cAAA,GAAiBA,cAAA,IAAkBC,cAAA;EACjE;AACF;;;;;;;AAQD,MAAMC,wBAAA,GAA4B9C,OAAA,IAA2E;EAC3G,OAAQD,MAAA,IAAoB;IAC1B,KAAKC,OAAA,CAAQ+C,MAAA,EACX,OAAO;IAGT,MAAMC,oBAAA,GAAuB7B,yBAAA,CAA0BpB,MAAA,EAAQC,OAAA,CAAQ;IACvE,MAAMiD,gBAAA,GAAmBpD,qBAAA,CAAsBE,MAAA,EAAQC,OAAA,CAAQ;IAC/D,MAAMkD,2BAAA,GAA8Bb,gCAAA,CAAiCtC,MAAA,EAAQC,OAAA,CAAQ;IAErF,IAAI,CAACgD,oBAAA,IAAwBC,gBAAA,EAAkBC,2BAA4B,EAACC,IAAA,CAAKC,CAAA,IAAKA,CAAA,KAAM,KAAK,EAC/F,OAAO,CAACJ,oBAAA,IAAwBC,gBAAA,EAAkBC,2BAA4B,EAACC,IAAA,CAAKC,CAAA,IAAKA,CAAA,KAAM,KAAK;IAGtG,OAAO,CAACJ,oBAAA,IAAwBC,gBAAA,EAAkBC,2BAA4B,EAACG,KAAA,CAAMD,CAAA,IAAKA,CAAA,KAAM,KAAK;EACtG;AACF;;;;;;AAyBD,MAAME,gBAAA,GAAmBA,CAAC;EACxBC,UAAA,EAAY;IACVC,SAAA;IACAC,aAAA;IACAV,MAAA;IACAW,KAAA;IACAzD,KAAA;IACAC,OAAA;IACAyD,OAAA;IACAC,OAAA;IACAC,QAAA;IACAtE,GAAA;IACAuE;EAAA,CACD;EACD9D,OAAA,EAAS;IAAE+D,uBAAA,GAA0B;EAAA;AAAM,CAC1B,KAAgC;EACjD,IAAIP,SAAA,eAA2BT,MAAA,aAC7B,OAAO;IACLiB,QAAA,EAAU;IACVC,UAAA;IACAT,SAAA;IACAM,aAAA;IACAf,MAAA;IACAW,KAAA;IACAzD,KAAA;IACAC,OAAA;IACAyD,OAAA;IACApE,GAAA;IACAqE,OAAA;IACAC;EACD;EAGH,IAAIL,SAAA,KAAc,QAAQT,MAAA,KAAW,MACnC,OAAO;IACLiB,QAAA,EAAU;IACVC,UAAA,EAAY;IACZT,SAAA;IACAT,MAAA;IACAe,aAAA,EAAe;IACfJ,KAAA,EAAO;IACPzD,KAAA,EAAO;IACPC,OAAA,EAAS;IACTyD,OAAA,EAAS;IACTpE,GAAA,EAAKA,CAAA,KAAM;IACXqE,OAAA;IACAC;EACD;EAGH,IAAIE,uBAAA,IAA2BN,aAAA,KAAkB,WAC/C,OAAO;IACLO,QAAA,EAAU;IACVC,UAAA,EAAY;IACZT,SAAA,EAAW;IACXT,MAAA,EAAQ;IACRe,aAAA,EAAe;IACfJ,KAAA,EAAO;IACPzD,KAAA,EAAO;IACPC,OAAA,EAAS;IACTyD,OAAA,EAAS;IACTpE,GAAA,EAAKA,CAAA,KAAM;IACXqE,OAAA;IACAC;EACD;EAGH,MAAML,SAAA,MAAeM,aAAA,MAAmBf,MAAA,MAAY9C,KAAA,MAAWC,OAAA,EAC7D,OAAO;IACL8D,QAAA,EAAU;IACVC,UAAA,EAAY;IACZT,SAAA;IACAM,aAAA;IACAf,MAAA;IACAW,KAAA,EAAOA,KAAA,IAAS;IAChBzD,KAAA;IACAC,OAAA;IACAyD,OAAA,EAASA,OAAA,IAAW;IACpBpE,GAAA;IACAqE,OAAA;IACAC;EACD;EAGH,MAAML,SAAA,MAAeM,aAAA,MAAmBf,MAAA,KAAW9C,KAAA,EACjD,OAAO;IACL+D,QAAA,EAAU;IACVC,UAAA,EAAY;IACZT,SAAA;IACAM,aAAA;IACAf,MAAA;IACAW,KAAA,EAAOA,KAAA,IAAS;IAChBzD,KAAA,EAAO;IACPC,OAAA,EAAS;IACTyD,OAAA,EAAS;IACTpE,GAAA;IACAqE,OAAA;IACAC;EACD;AAEJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}