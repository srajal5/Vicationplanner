{"ast":null,"code":"//#region src/retry.ts\nconst defaultOptions = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_, iteration) => iteration < 5,\n  retryImmediately: false,\n  jitter: true\n};\nconst RETRY_IMMEDIATELY_DELAY = 100;\nconst sleep = async ms => new Promise(s => setTimeout(s, ms));\nconst applyJitter = (delay, jitter) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\nconst createExponentialDelayAsyncFn = opts => {\n  let timesCalled = 0;\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n  return async () => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\n/**\n* Retries a callback until it succeeds or the shouldRetry function returns false.\n* See {@link RetryOptions} for the available options.\n*/\nconst retry = async (callback, options = {}) => {\n  let iterations = 0;\n  const {\n    shouldRetry,\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    retryImmediately,\n    jitter,\n    onBeforeRetry\n  } = {\n    ...defaultOptions,\n    ...options\n  };\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter\n  });\n  while (true) try {\n    return await callback();\n  } catch (e) {\n    iterations++;\n    if (!shouldRetry(e, iterations)) throw e;\n    if (onBeforeRetry) await onBeforeRetry(iterations);\n    if (retryImmediately && iterations === 1) await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));else await delay();\n  }\n};\n\n//#endregion\nexport { retry };","map":{"version":3,"names":["defaultOptions","initialDelay","maxDelayBetweenRetries","factor","shouldRetry","_","iteration","retryImmediately","jitter","RETRY_IMMEDIATELY_DELAY","sleep","ms","Promise","s","setTimeout","applyJitter","delay","Math","random","createExponentialDelayAsyncFn","opts","timesCalled","calculateDelayInMs","constant","base","pow","min","retry","callback","options","iterations","onBeforeRetry","e"],"sources":["C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\retry.ts"],"sourcesContent":["type Milliseconds = number;\n\ntype RetryOptions = Partial<{\n  /**\n   * The initial delay before the first retry.\n   *\n   * @default 125\n   */\n  initialDelay: Milliseconds;\n  /**\n   * The maximum delay between retries.\n   * The delay between retries will never exceed this value.\n   * If set to 0, the delay will increase indefinitely.\n   *\n   * @default 0\n   */\n  maxDelayBetweenRetries: Milliseconds;\n  /**\n   * The multiplier for the exponential backoff.\n   *\n   * @default 2\n   */\n  factor: number;\n  /**\n   * A function to determine if the operation should be retried.\n   * The callback accepts the error that was thrown and the number of iterations.\n   * The iterations variable references the number of retries AFTER attempt\n   * that caused the error and starts at 1 (as in, this is the 1st, 2nd, nth retry).\n   *\n   * @default (error, iterations) => iterations < 5\n   */\n  shouldRetry: (error: unknown, iterations: number) => boolean;\n  /**\n   * Controls whether the helper should retry the operation immediately once before applying exponential backoff.\n   * The delay for the immediate retry is 100ms.\n   *\n   * @default false\n   */\n  retryImmediately: boolean;\n  /**\n   * If true, the intervals will be multiplied by a factor in the range of [1,2].\n   *\n   * @default true\n   */\n  jitter: boolean;\n\n  /**\n   * A callback that is invoked before each retry attempt.\n   * The callback receives the iteration number (starting from 1 for the first retry).\n   * This can be used to modify request parameters, add headers, etc.\n   */\n  onBeforeRetry?: (iteration: number) => void | Promise<void>;\n}>;\n\nconst defaultOptions = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_: unknown, iteration: number) => iteration < 5,\n  retryImmediately: false,\n  jitter: true,\n};\n\nconst RETRY_IMMEDIATELY_DELAY = 100;\n\nconst sleep = async (ms: Milliseconds) => new Promise(s => setTimeout(s, ms));\n\nconst applyJitter = (delay: Milliseconds, jitter: boolean) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\n\nconst createExponentialDelayAsyncFn = (\n  opts: Required<Pick<RetryOptions, 'initialDelay' | 'maxDelayBetweenRetries' | 'factor' | 'jitter'>>,\n) => {\n  let timesCalled = 0;\n\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n\n  return async (): Promise<void> => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\n\n/**\n * Retries a callback until it succeeds or the shouldRetry function returns false.\n * See {@link RetryOptions} for the available options.\n */\nexport const retry = async <T>(callback: () => T | Promise<T>, options: RetryOptions = {}): Promise<T> => {\n  let iterations = 0;\n  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter, onBeforeRetry } = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter,\n  });\n\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterations++;\n      if (!shouldRetry(e, iterations)) {\n        throw e;\n      }\n\n      if (onBeforeRetry) {\n        await onBeforeRetry(iterations);\n      }\n\n      if (retryImmediately && iterations === 1) {\n        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));\n      } else {\n        await delay();\n      }\n    }\n  }\n};\n"],"mappings":";AAsDA,MAAMA,cAAA,GAAiB;EACrBC,YAAA,EAAc;EACdC,sBAAA,EAAwB;EACxBC,MAAA,EAAQ;EACRC,WAAA,EAAaA,CAACC,CAAA,EAAYC,SAAA,KAAsBA,SAAA,GAAY;EAC5DC,gBAAA,EAAkB;EAClBC,MAAA,EAAQ;AACT;AAED,MAAMC,uBAAA,GAA0B;AAEhC,MAAMC,KAAA,GAAQ,MAAOC,EAAA,IAAqB,IAAIC,OAAA,CAAQC,CAAA,IAAKC,UAAA,CAAWD,CAAA,EAAGF,EAAA,CAAG;AAE5E,MAAMI,WAAA,GAAcA,CAACC,KAAA,EAAqBR,MAAA,KAAoB;EAC5D,OAAOA,MAAA,GAASQ,KAAA,IAAS,IAAIC,IAAA,CAAKC,MAAA,EAAQ,IAAIF,KAAA;AAC/C;AAED,MAAMG,6BAAA,GACJC,IAAA,IACG;EACH,IAAIC,WAAA,GAAc;EAElB,MAAMC,kBAAA,GAAqBA,CAAA,KAAM;IAC/B,MAAMC,QAAA,GAAWH,IAAA,CAAKnB,YAAA;IACtB,MAAMuB,IAAA,GAAOJ,IAAA,CAAKjB,MAAA;IAClB,IAAIa,KAAA,GAAQO,QAAA,GAAWN,IAAA,CAAKQ,GAAA,CAAID,IAAA,EAAMH,WAAA,CAAY;IAClDL,KAAA,GAAQD,WAAA,CAAYC,KAAA,EAAOI,IAAA,CAAKZ,MAAA,CAAO;IACvC,OAAOS,IAAA,CAAKS,GAAA,CAAIN,IAAA,CAAKlB,sBAAA,IAA0Bc,KAAA,EAAOA,KAAA,CAAM;EAC7D;EAED,OAAO,YAA2B;IAChC,MAAMN,KAAA,CAAMY,kBAAA,EAAoB,CAAC;IACjCD,WAAA;EACD;AACF;;;;;AAMD,MAAaM,KAAA,GAAQ,MAAAA,CAAUC,QAAA,EAAgCC,OAAA,GAAwB,CAAE,MAAiB;EACxG,IAAIC,UAAA,GAAa;EACjB,MAAM;IAAE1B,WAAA;IAAaH,YAAA;IAAcC,sBAAA;IAAwBC,MAAA;IAAQI,gBAAA;IAAkBC,MAAA;IAAQuB;EAAA,CAAe,GAAG;IAC7G,GAAG/B,cAAA;IACH,GAAG6B;EACJ;EAED,MAAMb,KAAA,GAAQG,6BAAA,CAA8B;IAC1ClB,YAAA;IACAC,sBAAA;IACAC,MAAA;IACAK;EACD,EAAC;EAEF,OAAO,MACL,IAAI;IACF,OAAO,MAAMoB,QAAA,EAAU;EACxB,SAAQI,CAAA,EAAG;IACVF,UAAA;IACA,KAAK1B,WAAA,CAAY4B,CAAA,EAAGF,UAAA,CAAW,EAC7B,MAAME,CAAA;IAGR,IAAID,aAAA,EACF,MAAMA,aAAA,CAAcD,UAAA,CAAW;IAGjC,IAAIvB,gBAAA,IAAoBuB,UAAA,KAAe,GACrC,MAAMpB,KAAA,CAAMK,WAAA,CAAYN,uBAAA,EAAyBD,MAAA,CAAO,CAAC,MAEzD,MAAMQ,KAAA,EAAO;EAEhB;AAEJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}