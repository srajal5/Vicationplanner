{"ast":null,"code":"import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from '../index/index.mjs';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from '../_internal/index.mjs';\nconst startTransition = IS_REACT_LEGACY ? cb => {\n  cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n * @param initialState - The initial state object.\n */\nconst useStateWithDeps = initialState => {\n  const [, rerender] = useState({});\n  const unmountedRef = useRef(false);\n  const stateRef = useRef(initialState);\n  // If a state property (data, error, or isValidating) is accessed by the render\n  // function, we mark the property as a dependency so if it is updated again\n  // in the future, we trigger a rerender.\n  // This is also known as dependency-tracking.\n  const stateDependenciesRef = useRef({\n    data: false,\n    error: false,\n    isValidating: false\n  });\n  /**\n  * Updates state and triggers re-render if necessary.\n  * @param payload To change stateRef, pass the values explicitly to setState:\n  * @example\n  * ```js\n  * setState({\n  *   isValidating: false\n  *   data: newData // set data to newData\n  *   error: undefined // set error to undefined\n  * })\n  *\n  * setState({\n  *   isValidating: false\n  *   data: undefined // set data to undefined\n  *   error: err // set error to err\n  * })\n  * ```\n  */\n  const setState = useCallback(payload => {\n    let shouldRerender = false;\n    const currentState = stateRef.current;\n    for (const key in payload) {\n      if (Object.prototype.hasOwnProperty.call(payload, key)) {\n        const k = key;\n        // If the property has changed, update the state and mark rerender as\n        // needed.\n        if (currentState[k] !== payload[k]) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          currentState[k] = payload[k];\n          // If the property is accessed by the component, a rerender should be\n          // triggered.\n          if (stateDependenciesRef.current[k]) {\n            shouldRerender = true;\n          }\n        }\n      }\n    }\n    if (shouldRerender && !unmountedRef.current) {\n      rerender({});\n    }\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    unmountedRef.current = false;\n    return () => {\n      unmountedRef.current = true;\n    };\n  });\n  return [stateRef, stateDependenciesRef.current, setState];\n};\nconst mutation = () => function (key, fetcher) {\n  let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const {\n    mutate\n  } = useSWRConfig();\n  const keyRef = useRef(key);\n  const fetcherRef = useRef(fetcher);\n  const configRef = useRef(config);\n  // Ditch all mutation results that happened earlier than this timestamp.\n  const ditchMutationsUntilRef = useRef(0);\n  const [stateRef, stateDependencies, setState] = useStateWithDeps({\n    data: UNDEFINED,\n    error: UNDEFINED,\n    isMutating: false\n  });\n  const currentState = stateRef.current;\n  const trigger = useCallback(async (arg, opts) => {\n    const [serializedKey, resolvedKey] = serialize(keyRef.current);\n    if (!fetcherRef.current) {\n      throw new Error('Can’t trigger the mutation: missing fetcher.');\n    }\n    if (!serializedKey) {\n      throw new Error('Can’t trigger the mutation: missing key.');\n    }\n    // Disable cache population by default.\n    const options = mergeObjects(mergeObjects({\n      populateCache: false,\n      throwOnError: true\n    }, configRef.current), opts);\n    // Trigger a mutation, and also track the timestamp. Any mutation that happened\n    // earlier this timestamp should be ignored.\n    const mutationStartedAt = getTimestamp();\n    ditchMutationsUntilRef.current = mutationStartedAt;\n    setState({\n      isMutating: true\n    });\n    try {\n      const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n        arg\n      }),\n      // We must throw the error here so we can catch and update the states.\n      mergeObjects(options, {\n        throwOnError: true\n      }));\n      // If it's reset after the mutation, we don't broadcast any state change.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        startTransition(() => setState({\n          data,\n          isMutating: false,\n          error: undefined\n        }));\n        options.onSuccess == null ? void 0 : options.onSuccess.call(options, data, serializedKey, options);\n      }\n      return data;\n    } catch (error) {\n      // If it's reset after the mutation, we don't broadcast any state change\n      // or throw because it's discarded.\n      if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n        startTransition(() => setState({\n          error: error,\n          isMutating: false\n        }));\n        options.onError == null ? undefined : options.onError.call(options, error, serializedKey, options);\n        if (options.throwOnError) {\n          throw error;\n        }\n      }\n    }\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  const reset = useCallback(() => {\n    ditchMutationsUntilRef.current = getTimestamp();\n    setState({\n      data: UNDEFINED,\n      error: UNDEFINED,\n      isMutating: false\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    keyRef.current = key;\n    fetcherRef.current = fetcher;\n    configRef.current = config;\n  });\n  // We don't return `mutate` here as it can be pretty confusing (e.g. people\n  // calling `mutate` but they actually mean `trigger`).\n  // And also, `mutate` relies on the useSWR hook to exist too.\n  return {\n    trigger,\n    reset,\n    get data() {\n      stateDependencies.data = true;\n      return currentState.data;\n    },\n    get error() {\n      stateDependencies.error = true;\n      return currentState.error;\n    },\n    get isMutating() {\n      stateDependencies.isMutating = true;\n      return currentState.isMutating;\n    }\n  };\n};\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */\nconst useSWRMutation = withMiddleware(useSWR, mutation);\nexport { useSWRMutation as default };","map":{"version":3,"names":["React","useState","useRef","useCallback","useSWR","useSWRConfig","IS_REACT_LEGACY","useIsomorphicLayoutEffect","withMiddleware","serialize","mergeObjects","getTimestamp","UNDEFINED","startTransition","cb","useStateWithDeps","initialState","rerender","unmountedRef","stateRef","stateDependenciesRef","data","error","isValidating","setState","payload","shouldRerender","currentState","current","key","Object","prototype","hasOwnProperty","call","k","mutation","fetcher","config","arguments","length","undefined","mutate","keyRef","fetcherRef","configRef","ditchMutationsUntilRef","stateDependencies","isMutating","trigger","arg","opts","serializedKey","resolvedKey","Error","options","populateCache","throwOnError","mutationStartedAt","onSuccess","onError","reset","useSWRMutation","default"],"sources":["C:/Users/ASUS/Vicationplanner/frontend/node_modules/swr/dist/mutation/index.mjs"],"sourcesContent":["import React, { useState, useRef, useCallback } from 'react';\nimport useSWR, { useSWRConfig } from '../index/index.mjs';\nimport { IS_REACT_LEGACY, useIsomorphicLayoutEffect, withMiddleware, serialize, mergeObjects, getTimestamp, UNDEFINED } from '../_internal/index.mjs';\n\nconst startTransition = IS_REACT_LEGACY ? (cb)=>{\n    cb();\n} : React.startTransition;\n/**\n * An implementation of state with dependency-tracking.\n * @param initialState - The initial state object.\n */ const useStateWithDeps = (initialState)=>{\n    const [, rerender] = useState({});\n    const unmountedRef = useRef(false);\n    const stateRef = useRef(initialState);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * Updates state and triggers re-render if necessary.\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = useCallback((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const key in payload){\n            if (Object.prototype.hasOwnProperty.call(payload, key)) {\n                const k = key;\n                // If the property has changed, update the state and mark rerender as\n                // needed.\n                if (currentState[k] !== payload[k]) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    currentState[k] = payload[k];\n                    // If the property is accessed by the component, a rerender should be\n                    // triggered.\n                    if (stateDependenciesRef.current[k]) {\n                        shouldRerender = true;\n                    }\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            rerender({});\n        }\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n\nconst mutation = ()=>(key, fetcher, config = {})=>{\n        const { mutate } = useSWRConfig();\n        const keyRef = useRef(key);\n        const fetcherRef = useRef(fetcher);\n        const configRef = useRef(config);\n        // Ditch all mutation results that happened earlier than this timestamp.\n        const ditchMutationsUntilRef = useRef(0);\n        const [stateRef, stateDependencies, setState] = useStateWithDeps({\n            data: UNDEFINED,\n            error: UNDEFINED,\n            isMutating: false\n        });\n        const currentState = stateRef.current;\n        const trigger = useCallback(async (arg, opts)=>{\n            const [serializedKey, resolvedKey] = serialize(keyRef.current);\n            if (!fetcherRef.current) {\n                throw new Error('Can’t trigger the mutation: missing fetcher.');\n            }\n            if (!serializedKey) {\n                throw new Error('Can’t trigger the mutation: missing key.');\n            }\n            // Disable cache population by default.\n            const options = mergeObjects(mergeObjects({\n                populateCache: false,\n                throwOnError: true\n            }, configRef.current), opts);\n            // Trigger a mutation, and also track the timestamp. Any mutation that happened\n            // earlier this timestamp should be ignored.\n            const mutationStartedAt = getTimestamp();\n            ditchMutationsUntilRef.current = mutationStartedAt;\n            setState({\n                isMutating: true\n            });\n            try {\n                const data = await mutate(serializedKey, fetcherRef.current(resolvedKey, {\n                    arg\n                }), // We must throw the error here so we can catch and update the states.\n                mergeObjects(options, {\n                    throwOnError: true\n                }));\n                // If it's reset after the mutation, we don't broadcast any state change.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    startTransition(()=>setState({\n                            data,\n                            isMutating: false,\n                            error: undefined\n                        }));\n                    options.onSuccess == null ? void 0 : options.onSuccess.call(options, data, serializedKey, options);\n                }\n                return data;\n            } catch (error) {\n                // If it's reset after the mutation, we don't broadcast any state change\n                // or throw because it's discarded.\n                if (ditchMutationsUntilRef.current <= mutationStartedAt) {\n                    startTransition(()=>setState({\n                            error: error,\n                            isMutating: false\n                        }));\n                    options.onError == null ? undefined : options.onError.call(options, error, serializedKey, options);\n                    if (options.throwOnError) {\n                        throw error;\n                    }\n                }\n            }\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        []);\n        const reset = useCallback(()=>{\n            ditchMutationsUntilRef.current = getTimestamp();\n            setState({\n                data: UNDEFINED,\n                error: UNDEFINED,\n                isMutating: false\n            });\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n        useIsomorphicLayoutEffect(()=>{\n            keyRef.current = key;\n            fetcherRef.current = fetcher;\n            configRef.current = config;\n        });\n        // We don't return `mutate` here as it can be pretty confusing (e.g. people\n        // calling `mutate` but they actually mean `trigger`).\n        // And also, `mutate` relies on the useSWR hook to exist too.\n        return {\n            trigger,\n            reset,\n            get data () {\n                stateDependencies.data = true;\n                return currentState.data;\n            },\n            get error () {\n                stateDependencies.error = true;\n                return currentState.error;\n            },\n            get isMutating () {\n                stateDependencies.isMutating = true;\n                return currentState.isMutating;\n            }\n        };\n    };\n/**\n * A hook to define and manually trigger remote mutations like POST, PUT, DELETE and PATCH use cases.\n *\n * @link https://swr.vercel.app/docs/mutation\n * @example\n * ```jsx\n * import useSWRMutation from 'swr/mutation'\n *\n * const {\n *   data,\n *   error,\n *   trigger,\n *   reset,\n *   isMutating\n * } = useSWRMutation(key, fetcher, options?)\n * ```\n */ const useSWRMutation = withMiddleware(useSWR, mutation);\n\nexport { useSWRMutation as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}