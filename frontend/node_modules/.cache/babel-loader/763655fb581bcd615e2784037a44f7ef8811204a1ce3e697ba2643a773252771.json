{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _assertClassBrand from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldSet from \"C:/Users/ASUS/Vicationplanner/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nconst _excluded = [\"sk\", \"pk\", \"payload\"];\nvar _cache, _cacheTtl, _Class_brand, _storageKey, _Class2_brand, _cache2, _maxSize, _config, _eventThrottler, _metadata, _buffer, _pendingFlush, _Class4_brand;\nimport { parsePublishableKey } from \"./keys-Dcilj3cS.mjs\";\nimport { isTruthy } from \"./underscore-DjQrhefX.mjs\";\n\n//#region src/telemetry/throttler.ts\nconst DEFAULT_CACHE_TTL_MS = 864e5;\n/**\n* Manages throttling for telemetry events using a configurable cache implementation\n* to mitigate event flooding in frequently executed code paths.\n*/\nvar TelemetryEventThrottler = (_cache = /*#__PURE__*/new WeakMap(), _cacheTtl = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class TelemetryEventThrottler {\n  constructor(cache) {\n    /**\n    * Generates a consistent unique key for telemetry events by sorting payload properties.\n    * This ensures that payloads with identical content in different orders produce the same key.\n    */\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _cache, void 0);\n    _classPrivateFieldInitSpec(this, _cacheTtl, DEFAULT_CACHE_TTL_MS);\n    _classPrivateFieldSet(_cache, this, cache);\n  }\n  isEventThrottled(payload) {\n    const now = Date.now();\n    const key = _assertClassBrand(_Class_brand, this, _generateKey).call(this, payload);\n    const entry = _classPrivateFieldGet(_cache, this).getItem(key);\n    if (!entry) {\n      _classPrivateFieldGet(_cache, this).setItem(key, now);\n      return false;\n    }\n    const shouldInvalidate = now - entry > _classPrivateFieldGet(_cacheTtl, this);\n    if (shouldInvalidate) {\n      _classPrivateFieldGet(_cache, this).setItem(key, now);\n      return false;\n    }\n    return true;\n  }\n});\n/**\n* LocalStorage-based cache implementation for browser environments.\n*/\nfunction _generateKey(event) {\n  const {\n      sk: _sk,\n      pk: _pk,\n      payload\n    } = event,\n    rest = _objectWithoutProperties(event, _excluded);\n  const sanitizedEvent = _objectSpread(_objectSpread({}, payload), rest);\n  return JSON.stringify(Object.keys(_objectSpread(_objectSpread({}, payload), rest)).sort().map(key => sanitizedEvent[key]));\n}\nvar LocalStorageThrottlerCache = (_storageKey = /*#__PURE__*/new WeakMap(), _Class2_brand = /*#__PURE__*/new WeakSet(), class LocalStorageThrottlerCache {\n  constructor() {\n    _classPrivateMethodInitSpec(this, _Class2_brand);\n    _classPrivateFieldInitSpec(this, _storageKey, \"clerk_telemetry_throttler\");\n  }\n  getItem(key) {\n    return _assertClassBrand(_Class2_brand, this, _getCache).call(this)[key];\n  }\n  setItem(key, value) {\n    try {\n      const cache = _assertClassBrand(_Class2_brand, this, _getCache).call(this);\n      cache[key] = value;\n      localStorage.setItem(_classPrivateFieldGet(_storageKey, this), JSON.stringify(cache));\n    } catch (err) {\n      const isQuotaExceededError = err instanceof DOMException && (err.name === \"QuotaExceededError\" || err.name === \"NS_ERROR_DOM_QUOTA_REACHED\");\n      if (isQuotaExceededError && localStorage.length > 0) localStorage.removeItem(_classPrivateFieldGet(_storageKey, this));\n    }\n  }\n  removeItem(key) {\n    try {\n      const cache = _assertClassBrand(_Class2_brand, this, _getCache).call(this);\n      delete cache[key];\n      localStorage.setItem(_classPrivateFieldGet(_storageKey, this), JSON.stringify(cache));\n    } catch (_unused) {}\n  }\n  static isSupported() {\n    return typeof window !== \"undefined\" && !!window.localStorage;\n  }\n});\n/**\n* In-memory cache implementation for non-browser environments (e.g., React Native).\n*/\nfunction _getCache() {\n  try {\n    const cacheString = localStorage.getItem(_classPrivateFieldGet(_storageKey, this));\n    if (!cacheString) return {};\n    return JSON.parse(cacheString);\n  } catch (_unused2) {\n    return {};\n  }\n}\nvar InMemoryThrottlerCache = (_cache2 = /*#__PURE__*/new WeakMap(), _maxSize = /*#__PURE__*/new WeakMap(), class InMemoryThrottlerCache {\n  constructor() {\n    _classPrivateFieldInitSpec(this, _cache2, new Map());\n    _classPrivateFieldInitSpec(this, _maxSize, 1e4);\n  }\n  getItem(key) {\n    if (_classPrivateFieldGet(_cache2, this).size > _classPrivateFieldGet(_maxSize, this)) {\n      _classPrivateFieldGet(_cache2, this).clear();\n      return void 0;\n    }\n    return _classPrivateFieldGet(_cache2, this).get(key);\n  }\n  setItem(key, value) {\n    _classPrivateFieldGet(_cache2, this).set(key, value);\n  }\n  removeItem(key) {\n    _classPrivateFieldGet(_cache2, this).delete(key);\n  }\n});\n\n//#endregion\n//#region src/telemetry/collector.ts\n/**\n* Type guard to check if window.Clerk exists and has the expected structure.\n*/\nfunction isWindowClerkWithMetadata(clerk) {\n  return typeof clerk === \"object\" && clerk !== null && \"constructor\" in clerk && typeof clerk.constructor === \"function\";\n}\nconst VALID_LOG_LEVELS = new Set([\"error\", \"warn\", \"info\", \"debug\", \"trace\"]);\nconst DEFAULT_CONFIG = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  endpoint: \"https://clerk-telemetry.com\"\n};\nvar TelemetryCollector = (_config = /*#__PURE__*/new WeakMap(), _eventThrottler = /*#__PURE__*/new WeakMap(), _metadata = /*#__PURE__*/new WeakMap(), _buffer = /*#__PURE__*/new WeakMap(), _pendingFlush = /*#__PURE__*/new WeakMap(), _Class4_brand = /*#__PURE__*/new WeakSet(), class TelemetryCollector {\n  constructor(options) {\n    var _options$maxBufferSiz, _options$samplingRate, _options$perEventSamp, _options$disabled, _options$debug, _options$clerkVersion, _options$publishableK;\n    _classPrivateMethodInitSpec(this, _Class4_brand);\n    _classPrivateFieldInitSpec(this, _config, void 0);\n    _classPrivateFieldInitSpec(this, _eventThrottler, void 0);\n    _classPrivateFieldInitSpec(this, _metadata, {});\n    _classPrivateFieldInitSpec(this, _buffer, []);\n    _classPrivateFieldInitSpec(this, _pendingFlush, null);\n    _classPrivateFieldSet(_config, this, {\n      maxBufferSize: (_options$maxBufferSiz = options.maxBufferSize) !== null && _options$maxBufferSiz !== void 0 ? _options$maxBufferSiz : DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: (_options$samplingRate = options.samplingRate) !== null && _options$samplingRate !== void 0 ? _options$samplingRate : DEFAULT_CONFIG.samplingRate,\n      perEventSampling: (_options$perEventSamp = options.perEventSampling) !== null && _options$perEventSamp !== void 0 ? _options$perEventSamp : true,\n      disabled: (_options$disabled = options.disabled) !== null && _options$disabled !== void 0 ? _options$disabled : false,\n      debug: (_options$debug = options.debug) !== null && _options$debug !== void 0 ? _options$debug : false,\n      endpoint: DEFAULT_CONFIG.endpoint\n    });\n    if (!options.clerkVersion && typeof window === \"undefined\") _classPrivateFieldGet(_metadata, this).clerkVersion = \"\";else _classPrivateFieldGet(_metadata, this).clerkVersion = (_options$clerkVersion = options.clerkVersion) !== null && _options$clerkVersion !== void 0 ? _options$clerkVersion : \"\";\n    _classPrivateFieldGet(_metadata, this).sdk = options.sdk;\n    _classPrivateFieldGet(_metadata, this).sdkVersion = options.sdkVersion;\n    _classPrivateFieldGet(_metadata, this).publishableKey = (_options$publishableK = options.publishableKey) !== null && _options$publishableK !== void 0 ? _options$publishableK : \"\";\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) _classPrivateFieldGet(_metadata, this).instanceType = parsedKey.instanceType;\n    if (options.secretKey) _classPrivateFieldGet(_metadata, this).secretKey = options.secretKey.substring(0, 16);\n    const cache = LocalStorageThrottlerCache.isSupported() ? new LocalStorageThrottlerCache() : new InMemoryThrottlerCache();\n    _classPrivateFieldSet(_eventThrottler, this, new TelemetryEventThrottler(cache));\n  }\n  get isEnabled() {\n    var _window;\n    if (_classPrivateFieldGet(_metadata, this).instanceType !== \"development\") return false;\n    if (_classPrivateFieldGet(_config, this).disabled || typeof process !== \"undefined\" && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED)) return false;\n    if (typeof window !== \"undefined\" && !!((_window = window) !== null && _window !== void 0 && (_window = _window.navigator) !== null && _window !== void 0 && _window.webdriver)) return false;\n    return true;\n  }\n  get isDebug() {\n    return _classPrivateFieldGet(_config, this).debug || typeof process !== \"undefined\" && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG);\n  }\n  record(event) {\n    try {\n      const preparedPayload = _assertClassBrand(_Class4_brand, this, _preparePayload).call(this, event.event, event.payload);\n      _assertClassBrand(_Class4_brand, this, _logEvent).call(this, preparedPayload.event, preparedPayload);\n      if (!_assertClassBrand(_Class4_brand, this, _shouldRecord).call(this, preparedPayload, event.eventSamplingRate)) return;\n      _classPrivateFieldGet(_buffer, this).push({\n        kind: \"event\",\n        value: preparedPayload\n      });\n      _assertClassBrand(_Class4_brand, this, _scheduleFlush).call(this);\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry event\", error);\n    }\n  }\n  /**\n  * Records a telemetry log entry if logging is enabled and not in debug mode.\n  *\n  * @param entry - The telemetry log entry to record.\n  */\n  recordLog(entry) {\n    try {\n      var _classPrivateFieldGet2;\n      if (!_assertClassBrand(_Class4_brand, this, _shouldRecordLog).call(this, entry)) return;\n      const levelIsValid = typeof (entry === null || entry === void 0 ? void 0 : entry.level) === \"string\" && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof (entry === null || entry === void 0 ? void 0 : entry.message) === \"string\" && entry.message.trim().length > 0;\n      let normalizedTimestamp = null;\n      const timestampInput = entry === null || entry === void 0 ? void 0 : entry.timestamp;\n      if (typeof timestampInput === \"number\" || typeof timestampInput === \"string\") {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) normalizedTimestamp = candidate;\n      }\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== \"undefined\") console.warn(\"[clerk/telemetry] Dropping invalid telemetry log entry\", {\n          levelIsValid,\n          messageIsValid,\n          timestampIsValid: normalizedTimestamp !== null\n        });\n        return;\n      }\n      const sdkMetadata = _assertClassBrand(_Class4_brand, this, _getSDKMetadata).call(this);\n      const logData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: (_classPrivateFieldGet2 = _classPrivateFieldGet(_metadata, this).clerkVersion) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : \"\",\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: _classPrivateFieldGet(_metadata, this).publishableKey || null,\n        payload: _assertClassBrand(_Class4_brand, this, _sanitizeContext).call(this, entry.context)\n      };\n      _classPrivateFieldGet(_buffer, this).push({\n        kind: \"log\",\n        value: logData\n      });\n      _assertClassBrand(_Class4_brand, this, _scheduleFlush).call(this);\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry log entry\", error);\n    }\n  }\n});\n\n//#endregion\n//#region src/telemetry/events/component-mounted.ts\nfunction _shouldRecord(preparedPayload, eventSamplingRate) {\n  return this.isEnabled && !this.isDebug && _assertClassBrand(_Class4_brand, this, _shouldBeSampled).call(this, preparedPayload, eventSamplingRate);\n}\nfunction _shouldRecordLog(_entry) {\n  return true;\n}\nfunction _shouldBeSampled(preparedPayload, eventSamplingRate) {\n  const randomSeed = Math.random();\n  const toBeSampled = randomSeed <= _classPrivateFieldGet(_config, this).samplingRate && (_classPrivateFieldGet(_config, this).perEventSampling === false || typeof eventSamplingRate === \"undefined\" || randomSeed <= eventSamplingRate);\n  if (!toBeSampled) return false;\n  return !_classPrivateFieldGet(_eventThrottler, this).isEventThrottled(preparedPayload);\n}\nfunction _scheduleFlush() {\n  if (typeof window === \"undefined\") {\n    _assertClassBrand(_Class4_brand, this, _flush).call(this);\n    return;\n  }\n  const isBufferFull = _classPrivateFieldGet(_buffer, this).length >= _classPrivateFieldGet(_config, this).maxBufferSize;\n  if (isBufferFull) {\n    if (_classPrivateFieldGet(_pendingFlush, this)) if (typeof cancelIdleCallback !== \"undefined\") cancelIdleCallback(Number(_classPrivateFieldGet(_pendingFlush, this)));else clearTimeout(Number(_classPrivateFieldGet(_pendingFlush, this)));\n    _assertClassBrand(_Class4_brand, this, _flush).call(this);\n    return;\n  }\n  if (_classPrivateFieldGet(_pendingFlush, this)) return;\n  if (\"requestIdleCallback\" in window) _classPrivateFieldSet(_pendingFlush, this, requestIdleCallback(() => {\n    _assertClassBrand(_Class4_brand, this, _flush).call(this);\n    _classPrivateFieldSet(_pendingFlush, this, null);\n  }));else _classPrivateFieldSet(_pendingFlush, this, setTimeout(() => {\n    _assertClassBrand(_Class4_brand, this, _flush).call(this);\n    _classPrivateFieldSet(_pendingFlush, this, null);\n  }, 0));\n}\nfunction _flush() {\n  const itemsToSend = [..._classPrivateFieldGet(_buffer, this)];\n  _classPrivateFieldSet(_buffer, this, []);\n  _classPrivateFieldSet(_pendingFlush, this, null);\n  if (itemsToSend.length === 0) return;\n  const eventsToSend = itemsToSend.filter(item => item.kind === \"event\").map(item => item.value);\n  const logsToSend = itemsToSend.filter(item => item.kind === \"log\").map(item => item.value);\n  if (eventsToSend.length > 0) {\n    const eventsUrl = new URL(\"/v1/event\", _classPrivateFieldGet(_config, this).endpoint);\n    fetch(eventsUrl, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      keepalive: true,\n      method: \"POST\",\n      body: JSON.stringify({\n        events: eventsToSend\n      })\n    }).catch(() => void 0);\n  }\n  if (logsToSend.length > 0) {\n    const logsUrl = new URL(\"/v1/logs\", _classPrivateFieldGet(_config, this).endpoint);\n    fetch(logsUrl, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      keepalive: true,\n      method: \"POST\",\n      body: JSON.stringify({\n        logs: logsToSend\n      })\n    }).catch(() => void 0);\n  }\n}\n/**\n* If running in debug mode, log the event and its payload to the console.\n*/\nfunction _logEvent(event, payload) {\n  if (!this.isDebug) return;\n  if (typeof console.groupCollapsed !== \"undefined\") {\n    console.groupCollapsed(\"[clerk/telemetry]\", event);\n    console.log(payload);\n    console.groupEnd();\n  } else console.log(\"[clerk/telemetry]\", event, payload);\n}\n/**\n* If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n*\n* This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n*/\nfunction _getSDKMetadata() {\n  const sdkMetadata = {\n    name: _classPrivateFieldGet(_metadata, this).sdk,\n    version: _classPrivateFieldGet(_metadata, this).sdkVersion\n  };\n  if (typeof window !== \"undefined\") {\n    const windowWithClerk = window;\n    if (windowWithClerk.Clerk) {\n      const windowClerk = windowWithClerk.Clerk;\n      if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n        const {\n          name,\n          version\n        } = windowClerk.constructor.sdkMetadata;\n        if (name !== void 0) sdkMetadata.name = name;\n        if (version !== void 0) sdkMetadata.version = version;\n      }\n    }\n  }\n  return sdkMetadata;\n}\n/**\n* Append relevant metadata from the Clerk singleton to the event payload.\n*/\nfunction _preparePayload(event, payload) {\n  var _classPrivateFieldGet3, _classPrivateFieldGet4;\n  const sdkMetadata = _assertClassBrand(_Class4_brand, this, _getSDKMetadata).call(this);\n  return _objectSpread(_objectSpread(_objectSpread({\n    event,\n    cv: (_classPrivateFieldGet3 = _classPrivateFieldGet(_metadata, this).clerkVersion) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : \"\",\n    it: (_classPrivateFieldGet4 = _classPrivateFieldGet(_metadata, this).instanceType) !== null && _classPrivateFieldGet4 !== void 0 ? _classPrivateFieldGet4 : \"\",\n    sdk: sdkMetadata.name,\n    sdkv: sdkMetadata.version\n  }, _classPrivateFieldGet(_metadata, this).publishableKey ? {\n    pk: _classPrivateFieldGet(_metadata, this).publishableKey\n  } : {}), _classPrivateFieldGet(_metadata, this).secretKey ? {\n    sk: _classPrivateFieldGet(_metadata, this).secretKey\n  } : {}), {}, {\n    payload\n  });\n}\n/**\n* Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n* values or null when the input is missing or not serializable. Arrays are not accepted.\n*/\nfunction _sanitizeContext(context) {\n  if (context === null || typeof context === \"undefined\") return null;\n  if (typeof context !== \"object\") return null;\n  try {\n    const cleaned = JSON.parse(JSON.stringify(context));\n    if (cleaned && typeof cleaned === \"object\" && !Array.isArray(cleaned)) return cleaned;\n    return null;\n  } catch (_unused3) {\n    return null;\n  }\n}\nconst EVENT_COMPONENT_MOUNTED = \"COMPONENT_MOUNTED\";\nconst EVENT_COMPONENT_OPENED = \"COMPONENT_OPENED\";\nconst EVENT_SAMPLING_RATE$3 = .1;\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set([\"SignIn\", \"SignUp\"]);\n/**\n* Returns the per-event sampling rate for component-mounted telemetry events.\n* Uses a higher rate for SignIn/SignUp to improve signal quality.\n*\n*  @internal\n*/\nfunction getComponentMountedSamplingRate(component) {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE$3;\n}\n/**\n* Factory for prebuilt component telemetry events.\n*\n* @internal\n*/\nfunction createPrebuiltComponentEvent(event) {\n  return function (component, props, additionalPayload) {\n    var _props$appearance, _props$appearance2, _props$appearance3;\n    return {\n      event,\n      eventSamplingRate: event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE$3,\n      payload: _objectSpread({\n        component,\n        appearanceProp: Boolean(props === null || props === void 0 ? void 0 : props.appearance),\n        baseTheme: Boolean(props === null || props === void 0 || (_props$appearance = props.appearance) === null || _props$appearance === void 0 ? void 0 : _props$appearance.baseTheme),\n        elements: Boolean(props === null || props === void 0 || (_props$appearance2 = props.appearance) === null || _props$appearance2 === void 0 ? void 0 : _props$appearance2.elements),\n        variables: Boolean(props === null || props === void 0 || (_props$appearance3 = props.appearance) === null || _props$appearance3 === void 0 ? void 0 : _props$appearance3.variables)\n      }, additionalPayload)\n    };\n  };\n}\n/**\n* Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n*\n* @param component - The name of the component.\n* @param props - The props passed to the component. Will be filtered to a known list of props.\n* @param additionalPayload - Additional data to send with the event.\n* @example\n* telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n*/\nfunction eventPrebuiltComponentMounted(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n/**\n* Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n*\n* @param component - The name of the component.\n* @param props - The props passed to the component. Will be filtered to a known list of props.\n* @param additionalPayload - Additional data to send with the event.\n* @example\n* telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n*/\nfunction eventPrebuiltComponentOpened(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n/**\n* Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n*\n* **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n*\n* @param component - The name of the component.\n* @param props - The props passed to the component. Ideally you only pass a handful of props here.\n* @example\n* telemetry.record(eventComponentMounted('SignUp', props));\n*/\nfunction eventComponentMounted(component) {\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: _objectSpread({\n      component\n    }, props)\n  };\n}\n\n//#endregion\n//#region src/telemetry/events/method-called.ts\nconst EVENT_METHOD_CALLED = \"METHOD_CALLED\";\nconst EVENT_SAMPLING_RATE$2 = .1;\n/**\n* Fired when a helper method is called from a Clerk SDK.\n*/\nfunction eventMethodCalled(method, payload) {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE$2,\n    payload: _objectSpread({\n      method\n    }, payload)\n  };\n}\n\n//#endregion\n//#region src/telemetry/events/framework-metadata.ts\nconst EVENT_FRAMEWORK_METADATA = \"FRAMEWORK_METADATA\";\nconst EVENT_SAMPLING_RATE$1 = .1;\n/**\n* Fired when a helper method is called from a Clerk SDK.\n*/\nfunction eventFrameworkMetadata(payload) {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE$1,\n    payload\n  };\n}\n\n//#endregion\n//#region src/telemetry/events/theme-usage.ts\nconst EVENT_THEME_USAGE = \"THEME_USAGE\";\nconst EVENT_SAMPLING_RATE = 1;\n/**\n* Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n*\n* @param appearance - The appearance prop from ClerkProvider.\n* @example\n* telemetry.record(eventThemeUsage(appearance));\n*/\nfunction eventThemeUsage(appearance) {\n  const payload = analyzeThemeUsage(appearance);\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload\n  };\n}\n/**\n* Analyzes the appearance prop to extract theme usage information for telemetry.\n*\n* @internal\n*/\nfunction analyzeThemeUsage(appearance) {\n  if (!appearance || typeof appearance !== \"object\") return {};\n  const themeProperty = appearance.theme || appearance.baseTheme;\n  if (!themeProperty) return {};\n  let themeName;\n  if (Array.isArray(themeProperty)) for (const theme of themeProperty) {\n    const name = extractThemeName(theme);\n    if (name) {\n      themeName = name;\n      break;\n    }\n  } else themeName = extractThemeName(themeProperty);\n  return {\n    themeName\n  };\n}\n/**\n* Extracts the theme name from a theme object.\n*\n* @internal\n*/\nfunction extractThemeName(theme) {\n  if (typeof theme === \"string\") return theme;\n  if (typeof theme === \"object\" && theme !== null) {\n    if (\"name\" in theme && typeof theme.name === \"string\") return theme.name;\n  }\n  return void 0;\n}\n\n//#endregion\nexport { EVENT_SAMPLING_RATE, EVENT_THEME_USAGE, TelemetryCollector, eventComponentMounted, eventFrameworkMetadata, eventMethodCalled, eventPrebuiltComponentMounted, eventPrebuiltComponentOpened, eventThemeUsage };","map":{"version":3,"names":["DEFAULT_CACHE_TTL_MS","TelemetryEventThrottler","_cache","WeakMap","_cacheTtl","_Class_brand","WeakSet","constructor","cache","_classPrivateFieldInitSpec","_classPrivateFieldSet","isEventThrottled","payload","now","Date","key","_assertClassBrand","_generateKey","call","entry","_classPrivateFieldGet","getItem","setItem","shouldInvalidate","event","sk","_sk","pk","_pk","rest","_objectWithoutProperties","_excluded","sanitizedEvent","_objectSpread","JSON","stringify","Object","keys","sort","map","LocalStorageThrottlerCache","_storageKey","_Class2_brand","_classPrivateMethodInitSpec","_getCache","value","localStorage","err","isQuotaExceededError","DOMException","name","length","removeItem","_unused","isSupported","window","cacheString","parse","_unused2","InMemoryThrottlerCache","_cache2","_maxSize","Map","size","clear","get","set","delete","isWindowClerkWithMetadata","clerk","VALID_LOG_LEVELS","Set","DEFAULT_CONFIG","samplingRate","maxBufferSize","endpoint","TelemetryCollector","_config","_eventThrottler","_metadata","_buffer","_pendingFlush","_Class4_brand","options","_options$maxBufferSiz","_options$samplingRate","_options$perEventSamp","_options$disabled","_options$debug","_options$clerkVersion","_options$publishableK","perEventSampling","disabled","debug","clerkVersion","sdk","sdkVersion","publishableKey","parsedKey","parsePublishableKey","instanceType","secretKey","substring","isEnabled","_window","process","env","isTruthy","CLERK_TELEMETRY_DISABLED","navigator","webdriver","isDebug","CLERK_TELEMETRY_DEBUG","record","preparedPayload","_preparePayload","_logEvent","_shouldRecord","eventSamplingRate","push","kind","_scheduleFlush","error","console","recordLog","_classPrivateFieldGet2","_shouldRecordLog","levelIsValid","level","has","messageIsValid","message","trim","normalizedTimestamp","timestampInput","timestamp","candidate","Number","isNaN","getTime","warn","timestampIsValid","sdkMetadata","_getSDKMetadata","logData","sdkv","version","cv","lvl","msg","ts","toISOString","_sanitizeContext","context","_shouldBeSampled","_entry","randomSeed","Math","random","toBeSampled","_flush","isBufferFull","cancelIdleCallback","clearTimeout","requestIdleCallback","setTimeout","itemsToSend","eventsToSend","filter","item","logsToSend","eventsUrl","URL","fetch","headers","keepalive","method","body","events","catch","logsUrl","logs","groupCollapsed","log","groupEnd","windowWithClerk","Clerk","windowClerk","_classPrivateFieldGet3","_classPrivateFieldGet4","it","cleaned","Array","isArray","_unused3","EVENT_COMPONENT_MOUNTED","EVENT_COMPONENT_OPENED","EVENT_SAMPLING_RATE$3","AUTH_COMPONENTS","getComponentMountedSamplingRate","component","createPrebuiltComponentEvent","props","additionalPayload","_props$appearance","_props$appearance2","_props$appearance3","appearanceProp","Boolean","appearance","baseTheme","elements","variables","eventPrebuiltComponentMounted","eventPrebuiltComponentOpened","eventComponentMounted","arguments","undefined","EVENT_METHOD_CALLED","EVENT_SAMPLING_RATE$2","eventMethodCalled","EVENT_FRAMEWORK_METADATA","EVENT_SAMPLING_RATE$1","eventFrameworkMetadata","EVENT_THEME_USAGE","EVENT_SAMPLING_RATE","eventThemeUsage","analyzeThemeUsage","themeProperty","theme","themeName","extractThemeName"],"sources":["C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\throttler.ts","C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\collector.ts","C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\component-mounted.ts","C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\method-called.ts","C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\framework-metadata.ts","C:\\Users\\ASUS\\Vicationplanner\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\theme-usage.ts"],"sourcesContent":["import type { TelemetryEvent } from '../types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Interface for cache storage used by the telemetry throttler.\n * Implementations can use localStorage, in-memory storage, or any other storage mechanism.\n */\nexport interface ThrottlerCache {\n  getItem(key: string): TtlInMilliseconds | undefined;\n  setItem(key: string, value: TtlInMilliseconds): void;\n  removeItem(key: string): void;\n}\n\n/**\n * Manages throttling for telemetry events using a configurable cache implementation\n * to mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #cache: ThrottlerCache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  constructor(cache: ThrottlerCache) {\n    this.#cache = cache;\n  }\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n}\n\n/**\n * LocalStorage-based cache implementation for browser environments.\n */\nexport class LocalStorageThrottlerCache implements ThrottlerCache {\n  #storageKey = 'clerk_telemetry_throttler';\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    return this.#getCache()[key];\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && localStorage.length > 0) {\n        // Clear our cache if quota exceeded\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n\n  removeItem(key: string): void {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n      // Silently fail if we can't remove\n    }\n  }\n\n  #getCache(): Record<string, TtlInMilliseconds> {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n\n  static isSupported(): boolean {\n    return typeof window !== 'undefined' && !!window.localStorage;\n  }\n}\n\n/**\n * In-memory cache implementation for non-browser environments (e.g., React Native).\n */\nexport class InMemoryThrottlerCache implements ThrottlerCache {\n  #cache: Map<string, TtlInMilliseconds> = new Map();\n  #maxSize = 10000; // Defensive limit to prevent memory issues\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    // Defensive: clear cache if it gets too large\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return undefined;\n    }\n\n    return this.#cache.get(key);\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    this.#cache.set(key, value);\n  }\n\n  removeItem(key: string): void {\n    this.#cache.delete(key);\n  }\n}\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport { parsePublishableKey } from '../keys';\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '../types';\nimport { isTruthy } from '../underscore';\nimport { InMemoryThrottlerCache, LocalStorageThrottlerCache, TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    // Use LocalStorage cache in browsers where it's supported, otherwise fall back to in-memory cache\n    const cache = LocalStorageThrottlerCache.isSupported()\n      ? new LocalStorageThrottlerCache()\n      : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set<string>(['SignIn', 'SignUp']);\n\n/**\n * Returns the per-event sampling rate for component-mounted telemetry events.\n * Uses a higher rate for SignIn/SignUp to improve signal quality.\n *\n *  @internal\n */\nfunction getComponentMountedSamplingRate(component: string): number {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * Factory for prebuilt component telemetry events.\n *\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate:\n        event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n","import type { Appearance, BaseTheme, TelemetryEventRaw } from '../../types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}